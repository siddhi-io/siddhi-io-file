{
    "docs": [
        {
            "location": "/",
            "text": "Siddhi IO File\n\u00b6\n\n\n\n  \n\n  \n\n  \n\n  \n\n  \n\n\nThe \nsiddhi-io-file extension\n is an extension to \nSiddhi\n which used to receive/publish event data from/to file. It supports both binary and text formats.\n\n\nFor information on \nSiddhi\n and it's features refer \nSiddhi Documentation\n. \n\n\nDownload\n\u00b6\n\n\n\n\nVersions 5.x and above with group id \nio.siddhi.extension.*\n from \nhere\n.\n\n\nVersions 4.x and lower with group id \norg.wso2.extension.siddhi.*\n from \nhere\n.\n\n\n\n\nLatest API Docs\n\u00b6\n\n\nLatest API Docs is \n2.0.5\n.\n\n\nFeatures\n\u00b6\n\n\n\n\nisDirectory\n \n(\nFunction\n)\n \nThis function checks for a given file path points to a directory\n\n\nisExist\n \n(\nFunction\n)\n \nThis function checks whether a file or a folder exists in a given path\n\n\nisFile\n \n(\nFunction\n)\n \nThis function checks for a given file path points to a file\n\n\nlastModifiedTime\n \n(\nFunction\n)\n \nChecks for the last modified time for a given file path\n\n\nsize\n \n(\nFunction\n)\n \nThis function checks for a given file's size\n\n\narchive\n \n(\nStream Function\n)\n \nArchives files and folders as a zip or in tar format that are available in the given file uri.\n\n\ncopy\n \n(\nStream Function\n)\n \nThis function performs copying file from one directory to another.\n\n\ncreate\n \n(\nStream Function\n)\n \nCreate a file or a folder in the given location\n\n\ndelete\n \n(\nStream Function\n)\n \nDeletes file/files in a particular path\n\n\nmove\n \n(\nStream Function\n)\n \nThis function performs copying file from one directory to another.\n\n\nsearch\n \n(\nStream Function\n)\n \nSearches files in a given folder and lists.\n\n\nsearchInArchive\n \n(\nStream Function\n)\n \nThis.\n\n\nunarchive\n \n(\nStream Function\n)\n \nThis function decompresses a given file\n\n\nfile\n \n(\nSink\n)\n \nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\nfile\n \n(\nSource\n)\n \nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\n\nDependencies\n\u00b6\n\n\nThere are no other dependencies needed for this extension.\n\n\nInstallation\n\u00b6\n\n\nFor installing this extension and to add the dependent jars on various siddhi execution environments refer Siddhi documentation section on \nadding extensions and jars\n.\n\n\nSupport and Contribution\n\u00b6\n\n\n\n\n\n\nWe encourage users to ask questions and get support via \nStackOverflow\n, make sure to add the \nsiddhi\n tag to the issue for better response.\n\n\n\n\n\n\nIf you find any issues related to the extension please report them on \nthe issue tracker\n.\n\n\n\n\n\n\nFor production support and other contribution related information refer \nSiddhi Community\n documentation.",
            "title": "Welcome"
        },
        {
            "location": "/#siddhi-io-file",
            "text": "The  siddhi-io-file extension  is an extension to  Siddhi  which used to receive/publish event data from/to file. It supports both binary and text formats.  For information on  Siddhi  and it's features refer  Siddhi Documentation .",
            "title": "Siddhi IO File"
        },
        {
            "location": "/#download",
            "text": "Versions 5.x and above with group id  io.siddhi.extension.*  from  here .  Versions 4.x and lower with group id  org.wso2.extension.siddhi.*  from  here .",
            "title": "Download"
        },
        {
            "location": "/#latest-api-docs",
            "text": "Latest API Docs is  2.0.5 .",
            "title": "Latest API Docs"
        },
        {
            "location": "/#features",
            "text": "isDirectory   ( Function )   This function checks for a given file path points to a directory  isExist   ( Function )   This function checks whether a file or a folder exists in a given path  isFile   ( Function )   This function checks for a given file path points to a file  lastModifiedTime   ( Function )   Checks for the last modified time for a given file path  size   ( Function )   This function checks for a given file's size  archive   ( Stream Function )   Archives files and folders as a zip or in tar format that are available in the given file uri.  copy   ( Stream Function )   This function performs copying file from one directory to another.  create   ( Stream Function )   Create a file or a folder in the given location  delete   ( Stream Function )   Deletes file/files in a particular path  move   ( Stream Function )   This function performs copying file from one directory to another.  search   ( Stream Function )   Searches files in a given folder and lists.  searchInArchive   ( Stream Function )   This.  unarchive   ( Stream Function )   This function decompresses a given file  file   ( Sink )   File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  file   ( Source )   File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.",
            "title": "Features"
        },
        {
            "location": "/#dependencies",
            "text": "There are no other dependencies needed for this extension.",
            "title": "Dependencies"
        },
        {
            "location": "/#installation",
            "text": "For installing this extension and to add the dependent jars on various siddhi execution environments refer Siddhi documentation section on  adding extensions and jars .",
            "title": "Installation"
        },
        {
            "location": "/#support-and-contribution",
            "text": "We encourage users to ask questions and get support via  StackOverflow , make sure to add the  siddhi  tag to the issue for better response.    If you find any issues related to the extension please report them on  the issue tracker .    For production support and other contribution related information refer  Siddhi Community  documentation.",
            "title": "Support and Contribution"
        },
        {
            "location": "/api/latest/",
            "text": "API Docs - v2.0.5\n\u00b6\n\n\n\n\nTested Siddhi Core version: \n5.1.5\n\n\nIt could also support other Siddhi Core minor versions.\n\n\n\n\nFile\n\u00b6\n\n\nisDirectory \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file path points to a directory\n\n\n\n\nSyntax\n\n\n<BOOL> file:isDirectory(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nThe path to be checked for a directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isDirectory(filePath) as isDirectory\n\n\n\n\n\n\n\n\nChecks whether the given path is a directory. Result will be returned as an boolean.\n\n\n\n\n\n\nisExist \n(Function)\n\u00b6\n\n\n\n\nThis function checks whether a file or a folder exists in a given path\n\n\n\n\nSyntax\n\n\n<BOOL> file:isExist(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nFile path to check for existence.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isExist('/User/wso2/source/test.txt') as exists\n\n\n\n\n\n\n\n\nChecks existence of a file in the given path. Result will be returned as an boolean .\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:isExist('/User/wso2/source/') as exists\n\n\n\n\n\n\n\n\nChecks existence of a folder in the given path. Result will be returned as an boolean .\n\n\n\n\n\n\nisFile \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file path points to a file\n\n\n\n\nSyntax\n\n\n<BOOL> file:isFile(<STRING> file.path)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.path\n\n        \nThe path to be checked for a file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isFile(filePath) as isFile\n\n\n\n\n\n\n\n\nChecks whether the given path is a file. Result will be returned as an boolean.\n\n\n\n\n\n\nlastModifiedTime \n(Function)\n\u00b6\n\n\n\n\nChecks for the last modified time for a given file path\n\n\n\n\nSyntax\n\n\n<STRING> file:lastModifiedTime(<STRING> uri)\n<STRING> file:lastModifiedTime(<STRING> uri, <STRING> datetime.format)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nFile path to be checked for te last modified time.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndatetime.format\n\n        \nFormat of the last modified datetime to be returned.\n\n        \nMM/dd/yyyy HH:mm:ss\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:lastModifiedTime(filePath) as lastModifiedTime\n\n\n\n\n\n\n\n\nLast modified datetime of a file will be returned as an string in MM/dd/yyyy HH:mm:ss.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:lastModifiedTime(filePath, dd/MM/yyyy HH:mm:ss) as lastModifiedTime\n\n\n\n\n\n\n\n\nLast modified datetime of a file will be returned as an string in 'dd/MM/yyyy HH:mm:ss' format.\n\n\n\n\n\n\nsize \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file's size\n\n\n\n\nSyntax\n\n\n<LONG> file:size(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path to the file or directory to be checked for the size.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:size('/User/wso2/source/test.txt') as fileSize\n\n\n\n\n\n\n\n\nSize of a file in a given path will be returned.\n\n\n\n\n\n\narchive \n(Stream Function)\n\u00b6\n\n\n\n\nArchives files and folders as a zip or in tar format that are available in the given file uri.\n\n\n\n\nSyntax\n\n\nfile:archive(<STRING> uri, <STRING> destination.dir.uri)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file or the directory\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute directory path of the the archived file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \narchive.type\n\n        \nArchive type can be zip or tar\n\n        \nzip\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be archived.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.subdirectories\n\n        \nThis flag is used to exclude the subdirectories and its files without archiving.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file.zip')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder in zip format and stores archive_destination folder as file.zip.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder in tar format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar', '.*test3.txt$')\n\n\n\n\n\n\n\n\nArchives files which adheres to '.*test3.txt$' regex in to_be_archived folder in tar format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', '', '', 'false')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder excluding the sub-folders in zip format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\ncopy \n(Stream Function)\n\u00b6\n\n\n\n\nThis function performs copying file from one directory to another.\n\n\n\n\nSyntax\n\n\nfile:copy(<STRING> uri, <STRING> destination.dir.uri)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the File or the directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute path of the destination directory.\nNote: Parent folder structure will be created if it does not exist.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be copied.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nThis flag is used to exclude parent folder when copying the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nisSuccess\n\n        \nStatus of the file copying operation (true if success)\n\n        \nBOOL\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:copy('/User/wso2/source/test.txt', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nCopies 'test.txt' in 'source' folder to the 'destination' folder.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nCopies 'source' folder to the 'destination' folder with all its content\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')\n\n\n\n\n\n\n\n\nCopies 'source' folder to the 'destination' folder ignoring files doesnt adhere to the given regex.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '', true)\n\n\n\n\n\n\n\n\nCopies only the files resides in 'source' folder to 'destination' folder.\n\n\n\n\n\n\ncreate \n(Stream Function)\n\u00b6\n\n\n\n\nCreate a file or a folder in the given location\n\n\n\n\nSyntax\n\n\nfile:create(<STRING> uri, <STRING> is.directory)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path which needs to be created.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nis.directory\n\n        \nThis flag is used when creating file path is a directory\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom CreateFileStream#file:create('/User/wso2/source/test.txt', false)\n\n\n\n\n\n\n\n\nCreates a file in the given path with the name of 'test.txt'.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfrom CreateFileStream#file:create('/User/wso2/source/', true)\n\n\n\n\n\n\n\n\nCreates a folder in the given path with the name of 'source'.\n\n\n\n\n\n\ndelete \n(Stream Function)\n\u00b6\n\n\n\n\nDeletes file/files in a particular path\n\n\n\n\nSyntax\n\n\nfile:delete(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file or the directory to be deleted.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom DeleteFileStream#file:delete('/User/wso2/source/test.txt')\n\n\n\n\n\n\n\n\nDeletes the file in the given path. \n\n\n\n\n\n\nEXAMPLE 2\n\n\nfrom DeleteFileStream#file:delete('/User/wso2/source/')\n\n\n\n\n\n\n\n\nDeletes the folder in the given path. \n\n\n\n\n\n\nmove \n(Stream Function)\n\u00b6\n\n\n\n\nThis function performs copying file from one directory to another.\n\n\n\n\nSyntax\n\n\nfile:move(<STRING> uri, <STRING> destination.dir.uri)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file or directory path.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute file path to the destination directory.\nNote: Parent folder structure will be created if it does not exist.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be moved.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nExclude parent folder when moving the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nisSuccess\n\n        \nStatus of the file moving operation (true if success)\n\n        \nBOOL\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:move('/User/wso2/source/test.txt', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nMoves 'test.txt' in 'source' folder to the 'destination' folder.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nMoves 'source' folder to the 'destination' folder with all its content\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')\n\n\n\n\n\n\n\n\nMoves 'source' folder to the 'destination' folder excluding files doesnt adhere to the given regex.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '', true)\n\n\n\n\n\n\n\n\nMoves only the files resides in 'source' folder to 'destination' folder.\n\n\n\n\n\n\nsearch \n(Stream Function)\n\u00b6\n\n\n\n\nSearches files in a given folder and lists.\n\n\n\n\nSyntax\n\n\nfile:search(<STRING> uri)\nfile:search(<STRING> uri, <STRING> include.by.regexp)\nfile:search(<STRING> uri, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path of the directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be searched.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nYes\n\n    \n\n    \n\n        \nexclude.subdirectories\n\n        \nThis flag is used to exclude the files un subdirectories when listing.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nfileNameList\n\n        \nThe lit file name matches in the directory.\n\n        \nOBJECT\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nListFileStream#file:search(filePath)\n\n\n\n\n\n\n\n\nThis will list all the files (also in sub-folders) in a given path.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nListFileStream#file:search(filePath, '.*test3.txt$')\n\n\n\n\n\n\n\n\nThis will list all the files (also in sub-folders) which adheres to a given regex file pattern in a given path.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nListFileStream#file:search(filePath, '.*test3.txt$', true)\n\n\n\n\n\n\n\n\nThis will list all the files excluding the files in sub-folders which adheres to a given regex file pattern in a given path.\n\n\n\n\n\n\nsearchInArchive \n(Stream Function)\n\u00b6\n\n\n\n\nThis.\n\n\n\n\nSyntax\n\n\nfile:searchInArchive(<STRING> uri)\nfile:searchInArchive(<STRING> uri, <STRING> include.by.regexp)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path of the zip or tar file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be searched.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nfileNameList\n\n        \nThe list file names in the archived file.\n\n        \nOBJECT\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nListArchivedFileStream#file:listFilesInArchive(filePath)\n\n\n\n\n\n\n\n\nLists the files inside the compressed file in the given path.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nListArchivedFileStream#file:listFilesInArchive(filePath, '.*test3.txt$')\n\n\n\n\n\n\n\n\nFilters file names adheres to the given regex and lists the files inside the compressed file in the given path.\n\n\n\n\n\n\nunarchive \n(Stream Function)\n\u00b6\n\n\n\n\nThis function decompresses a given file\n\n\n\n\nSyntax\n\n\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri)\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file to be decompressed in the format of zip or tar.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute path of the destination directory.\nNote: If the folder structure does not exist, it will be created.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nThis flag excludes parent folder when extracting the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:unarchive('/User/wso2/source/test.zip', '/User/wso2/destination')\n\n\n\n\n\n\n\n\nUnarchive a zip file in a given path to a given destination.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination')\n\n\n\n\n\n\n\n\nUnarchive a tar file in a given path to a given destination.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nfile:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination', true)\n\n\n\n\n\n\n\n\nUnarchive a tar file in a given path to a given destination excluding the root folder.\n\n\n\n\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.read.wait.timeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "latest"
        },
        {
            "location": "/api/latest/#api-docs-v205",
            "text": "Tested Siddhi Core version:  5.1.5  It could also support other Siddhi Core minor versions.",
            "title": "API Docs - v2.0.5"
        },
        {
            "location": "/api/latest/#file",
            "text": "",
            "title": "File"
        },
        {
            "location": "/api/latest/#isdirectory-function",
            "text": "This function checks for a given file path points to a directory   Syntax  <BOOL> file:isDirectory(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         The path to be checked for a directory. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isDirectory(filePath) as isDirectory   Checks whether the given path is a directory. Result will be returned as an boolean.",
            "title": "isDirectory (Function)"
        },
        {
            "location": "/api/latest/#isexist-function",
            "text": "This function checks whether a file or a folder exists in a given path   Syntax  <BOOL> file:isExist(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         File path to check for existence. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isExist('/User/wso2/source/test.txt') as exists   Checks existence of a file in the given path. Result will be returned as an boolean .   EXAMPLE 2  file:isExist('/User/wso2/source/') as exists   Checks existence of a folder in the given path. Result will be returned as an boolean .",
            "title": "isExist (Function)"
        },
        {
            "location": "/api/latest/#isfile-function",
            "text": "This function checks for a given file path points to a file   Syntax  <BOOL> file:isFile(<STRING> file.path)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.path \n         The path to be checked for a file. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isFile(filePath) as isFile   Checks whether the given path is a file. Result will be returned as an boolean.",
            "title": "isFile (Function)"
        },
        {
            "location": "/api/latest/#lastmodifiedtime-function",
            "text": "Checks for the last modified time for a given file path   Syntax  <STRING> file:lastModifiedTime(<STRING> uri)\n<STRING> file:lastModifiedTime(<STRING> uri, <STRING> datetime.format)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         File path to be checked for te last modified time. \n         \n         STRING \n         No \n         Yes \n     \n     \n         datetime.format \n         Format of the last modified datetime to be returned. \n         MM/dd/yyyy HH:mm:ss \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  file:lastModifiedTime(filePath) as lastModifiedTime   Last modified datetime of a file will be returned as an string in MM/dd/yyyy HH:mm:ss.   EXAMPLE 2  file:lastModifiedTime(filePath, dd/MM/yyyy HH:mm:ss) as lastModifiedTime   Last modified datetime of a file will be returned as an string in 'dd/MM/yyyy HH:mm:ss' format.",
            "title": "lastModifiedTime (Function)"
        },
        {
            "location": "/api/latest/#size-function",
            "text": "This function checks for a given file's size   Syntax  <LONG> file:size(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path to the file or directory to be checked for the size. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:size('/User/wso2/source/test.txt') as fileSize   Size of a file in a given path will be returned.",
            "title": "size (Function)"
        },
        {
            "location": "/api/latest/#archive-stream-function",
            "text": "Archives files and folders as a zip or in tar format that are available in the given file uri.   Syntax  file:archive(<STRING> uri, <STRING> destination.dir.uri)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file or the directory \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute directory path of the the archived file. \n         \n         STRING \n         No \n         Yes \n     \n     \n         archive.type \n         Archive type can be zip or tar \n         zip \n         STRING \n         Yes \n         No \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be archived. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.subdirectories \n         This flag is used to exclude the subdirectories and its files without archiving. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file.zip')   Archives to_be_archived folder in zip format and stores archive_destination folder as file.zip.   EXAMPLE 2  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar')   Archives to_be_archived folder in tar format and stores in archive_destination folder as file.tar.   EXAMPLE 3  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar', '.*test3.txt$')   Archives files which adheres to '.*test3.txt$' regex in to_be_archived folder in tar format and stores in archive_destination folder as file.tar.   EXAMPLE 4  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', '', '', 'false')   Archives to_be_archived folder excluding the sub-folders in zip format and stores in archive_destination folder as file.tar.",
            "title": "archive (Stream Function)"
        },
        {
            "location": "/api/latest/#copy-stream-function",
            "text": "This function performs copying file from one directory to another.   Syntax  file:copy(<STRING> uri, <STRING> destination.dir.uri)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the File or the directory. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute path of the destination directory. Note: Parent folder structure will be created if it does not exist. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be copied. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.root.dir \n         This flag is used to exclude parent folder when copying the content. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         isSuccess \n         Status of the file copying operation (true if success) \n         BOOL \n       Examples  EXAMPLE 1  InputStream#file:copy('/User/wso2/source/test.txt', 'User/wso2/destination/')   Copies 'test.txt' in 'source' folder to the 'destination' folder.   EXAMPLE 2  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/')   Copies 'source' folder to the 'destination' folder with all its content   EXAMPLE 3  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')   Copies 'source' folder to the 'destination' folder ignoring files doesnt adhere to the given regex.   EXAMPLE 4  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '', true)   Copies only the files resides in 'source' folder to 'destination' folder.",
            "title": "copy (Stream Function)"
        },
        {
            "location": "/api/latest/#create-stream-function",
            "text": "Create a file or a folder in the given location   Syntax  file:create(<STRING> uri, <STRING> is.directory)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path which needs to be created. \n         \n         STRING \n         No \n         Yes \n     \n     \n         is.directory \n         This flag is used when creating file path is a directory \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  from CreateFileStream#file:create('/User/wso2/source/test.txt', false)   Creates a file in the given path with the name of 'test.txt'.   EXAMPLE 2  from CreateFileStream#file:create('/User/wso2/source/', true)   Creates a folder in the given path with the name of 'source'.",
            "title": "create (Stream Function)"
        },
        {
            "location": "/api/latest/#delete-stream-function",
            "text": "Deletes file/files in a particular path   Syntax  file:delete(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file or the directory to be deleted. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  from DeleteFileStream#file:delete('/User/wso2/source/test.txt')   Deletes the file in the given path.    EXAMPLE 2  from DeleteFileStream#file:delete('/User/wso2/source/')   Deletes the folder in the given path.",
            "title": "delete (Stream Function)"
        },
        {
            "location": "/api/latest/#move-stream-function",
            "text": "This function performs copying file from one directory to another.   Syntax  file:move(<STRING> uri, <STRING> destination.dir.uri)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file or directory path. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute file path to the destination directory. Note: Parent folder structure will be created if it does not exist. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be moved. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.root.dir \n         Exclude parent folder when moving the content. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         isSuccess \n         Status of the file moving operation (true if success) \n         BOOL \n       Examples  EXAMPLE 1  InputStream#file:move('/User/wso2/source/test.txt', 'User/wso2/destination/')   Moves 'test.txt' in 'source' folder to the 'destination' folder.   EXAMPLE 2  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/')   Moves 'source' folder to the 'destination' folder with all its content   EXAMPLE 3  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')   Moves 'source' folder to the 'destination' folder excluding files doesnt adhere to the given regex.   EXAMPLE 4  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '', true)   Moves only the files resides in 'source' folder to 'destination' folder.",
            "title": "move (Stream Function)"
        },
        {
            "location": "/api/latest/#search-stream-function",
            "text": "Searches files in a given folder and lists.   Syntax  file:search(<STRING> uri)\nfile:search(<STRING> uri, <STRING> include.by.regexp)\nfile:search(<STRING> uri, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path of the directory. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be searched. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         Yes \n     \n     \n         exclude.subdirectories \n         This flag is used to exclude the files un subdirectories when listing. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         fileNameList \n         The lit file name matches in the directory. \n         OBJECT \n       Examples  EXAMPLE 1  ListFileStream#file:search(filePath)   This will list all the files (also in sub-folders) in a given path.   EXAMPLE 2  ListFileStream#file:search(filePath, '.*test3.txt$')   This will list all the files (also in sub-folders) which adheres to a given regex file pattern in a given path.   EXAMPLE 3  ListFileStream#file:search(filePath, '.*test3.txt$', true)   This will list all the files excluding the files in sub-folders which adheres to a given regex file pattern in a given path.",
            "title": "search (Stream Function)"
        },
        {
            "location": "/api/latest/#searchinarchive-stream-function",
            "text": "This.   Syntax  file:searchInArchive(<STRING> uri)\nfile:searchInArchive(<STRING> uri, <STRING> include.by.regexp)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path of the zip or tar file. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be searched. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         fileNameList \n         The list file names in the archived file. \n         OBJECT \n       Examples  EXAMPLE 1  ListArchivedFileStream#file:listFilesInArchive(filePath)   Lists the files inside the compressed file in the given path.   EXAMPLE 2  ListArchivedFileStream#file:listFilesInArchive(filePath, '.*test3.txt$')   Filters file names adheres to the given regex and lists the files inside the compressed file in the given path.",
            "title": "searchInArchive (Stream Function)"
        },
        {
            "location": "/api/latest/#unarchive-stream-function",
            "text": "This function decompresses a given file   Syntax  file:unarchive(<STRING> uri, <STRING> destination.dir.uri)\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file to be decompressed in the format of zip or tar. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute path of the destination directory. Note: If the folder structure does not exist, it will be created. \n         \n         STRING \n         No \n         Yes \n     \n     \n         exclude.root.dir \n         This flag excludes parent folder when extracting the content. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  file:unarchive('/User/wso2/source/test.zip', '/User/wso2/destination')   Unarchive a zip file in a given path to a given destination.   EXAMPLE 2  file:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination')   Unarchive a tar file in a given path to a given destination.   EXAMPLE 3  file:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination', true)   Unarchive a tar file in a given path to a given destination excluding the root folder.",
            "title": "unarchive (Stream Function)"
        },
        {
            "location": "/api/latest/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/latest/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files   Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);    Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/latest/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/latest/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.   Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n     \n     \n         file.read.wait.timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);    Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.   EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/",
            "text": "API Docs - v2.0.6-SNAPSHOT\n\u00b6\n\n\n\n\nTested Siddhi Core version: \n5.1.5\n\n\nIt could also support other Siddhi Core minor versions.\n\n\n\n\nFile\n\u00b6\n\n\nisDirectory \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file path points to a directory\n\n\n\n\nSyntax\n\n\n<BOOL> file:isDirectory(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nThe path to be checked for a directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isDirectory(filePath) as isDirectory\n\n\n\n\n\n\n\n\nChecks whether the given path is a directory. Result will be returned as an boolean.\n\n\n\n\n\n\nisExist \n(Function)\n\u00b6\n\n\n\n\nThis function checks whether a file or a folder exists in a given path\n\n\n\n\nSyntax\n\n\n<BOOL> file:isExist(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nFile path to check for existence.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isExist('/User/wso2/source/test.txt') as exists\n\n\n\n\n\n\n\n\nChecks existence of a file in the given path. Result will be returned as an boolean .\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:isExist('/User/wso2/source/') as exists\n\n\n\n\n\n\n\n\nChecks existence of a folder in the given path. Result will be returned as an boolean .\n\n\n\n\n\n\nisFile \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file path points to a file\n\n\n\n\nSyntax\n\n\n<BOOL> file:isFile(<STRING> file.path)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.path\n\n        \nThe path to be checked for a file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isFile(filePath) as isFile\n\n\n\n\n\n\n\n\nChecks whether the given path is a file. Result will be returned as an boolean.\n\n\n\n\n\n\nlastModifiedTime \n(Function)\n\u00b6\n\n\n\n\nChecks for the last modified time for a given file path\n\n\n\n\nSyntax\n\n\n<STRING> file:lastModifiedTime(<STRING> uri)\n<STRING> file:lastModifiedTime(<STRING> uri, <STRING> datetime.format)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nFile path to be checked for te last modified time.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndatetime.format\n\n        \nFormat of the last modified datetime to be returned.\n\n        \nMM/dd/yyyy HH:mm:ss\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:lastModifiedTime(filePath) as lastModifiedTime\n\n\n\n\n\n\n\n\nLast modified datetime of a file will be returned as an string in MM/dd/yyyy HH:mm:ss.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:lastModifiedTime(filePath, dd/MM/yyyy HH:mm:ss) as lastModifiedTime\n\n\n\n\n\n\n\n\nLast modified datetime of a file will be returned as an string in 'dd/MM/yyyy HH:mm:ss' format.\n\n\n\n\n\n\nsize \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file's size\n\n\n\n\nSyntax\n\n\n<LONG> file:size(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path to the file or directory to be checked for the size.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:size('/User/wso2/source/test.txt') as fileSize\n\n\n\n\n\n\n\n\nSize of a file in a given path will be returned.\n\n\n\n\n\n\narchive \n(Stream Function)\n\u00b6\n\n\n\n\nArchives files and folders as a zip or in tar format that are available in the given file uri.\n\n\n\n\nSyntax\n\n\nfile:archive(<STRING> uri, <STRING> destination.dir.uri)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file or the directory\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute directory path of the the archived file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \narchive.type\n\n        \nArchive type can be zip or tar\n\n        \nzip\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be archived.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.subdirectories\n\n        \nThis flag is used to exclude the subdirectories and its files without archiving.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file.zip')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder in zip format and stores archive_destination folder as file.zip.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder in tar format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar', '.*test3.txt$')\n\n\n\n\n\n\n\n\nArchives files which adheres to '.*test3.txt$' regex in to_be_archived folder in tar format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', '', '', 'false')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder excluding the sub-folders in zip format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\ncopy \n(Stream Function)\n\u00b6\n\n\n\n\nThis function performs copying file from one directory to another.\n\n\n\n\nSyntax\n\n\nfile:copy(<STRING> uri, <STRING> destination.dir.uri)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the File or the directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute path of the destination directory.\nNote: Parent folder structure will be created if it does not exist.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be copied.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nThis flag is used to exclude parent folder when copying the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nisSuccess\n\n        \nStatus of the file copying operation (true if success)\n\n        \nBOOL\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:copy('/User/wso2/source/test.txt', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nCopies 'test.txt' in 'source' folder to the 'destination' folder.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nCopies 'source' folder to the 'destination' folder with all its content\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')\n\n\n\n\n\n\n\n\nCopies 'source' folder to the 'destination' folder ignoring files doesnt adhere to the given regex.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '', true)\n\n\n\n\n\n\n\n\nCopies only the files resides in 'source' folder to 'destination' folder.\n\n\n\n\n\n\ncreate \n(Stream Function)\n\u00b6\n\n\n\n\nCreate a file or a folder in the given location\n\n\n\n\nSyntax\n\n\nfile:create(<STRING> uri, <STRING> is.directory)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path which needs to be created.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nis.directory\n\n        \nThis flag is used when creating file path is a directory\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom CreateFileStream#file:create('/User/wso2/source/test.txt', false)\n\n\n\n\n\n\n\n\nCreates a file in the given path with the name of 'test.txt'.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfrom CreateFileStream#file:create('/User/wso2/source/', true)\n\n\n\n\n\n\n\n\nCreates a folder in the given path with the name of 'source'.\n\n\n\n\n\n\ndelete \n(Stream Function)\n\u00b6\n\n\n\n\nDeletes file/files in a particular path\n\n\n\n\nSyntax\n\n\nfile:delete(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file or the directory to be deleted.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom DeleteFileStream#file:delete('/User/wso2/source/test.txt')\n\n\n\n\n\n\n\n\nDeletes the file in the given path. \n\n\n\n\n\n\nEXAMPLE 2\n\n\nfrom DeleteFileStream#file:delete('/User/wso2/source/')\n\n\n\n\n\n\n\n\nDeletes the folder in the given path. \n\n\n\n\n\n\nmove \n(Stream Function)\n\u00b6\n\n\n\n\nThis function performs copying file from one directory to another.\n\n\n\n\nSyntax\n\n\nfile:move(<STRING> uri, <STRING> destination.dir.uri)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file or directory path.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute file path to the destination directory.\nNote: Parent folder structure will be created if it does not exist.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be moved.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nExclude parent folder when moving the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nisSuccess\n\n        \nStatus of the file moving operation (true if success)\n\n        \nBOOL\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:move('/User/wso2/source/test.txt', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nMoves 'test.txt' in 'source' folder to the 'destination' folder.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nMoves 'source' folder to the 'destination' folder with all its content\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')\n\n\n\n\n\n\n\n\nMoves 'source' folder to the 'destination' folder excluding files doesnt adhere to the given regex.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '', true)\n\n\n\n\n\n\n\n\nMoves only the files resides in 'source' folder to 'destination' folder.\n\n\n\n\n\n\nsearch \n(Stream Function)\n\u00b6\n\n\n\n\nSearches files in a given folder and lists.\n\n\n\n\nSyntax\n\n\nfile:search(<STRING> uri)\nfile:search(<STRING> uri, <STRING> include.by.regexp)\nfile:search(<STRING> uri, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path of the directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be searched.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nYes\n\n    \n\n    \n\n        \nexclude.subdirectories\n\n        \nThis flag is used to exclude the files un subdirectories when listing.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nfileNameList\n\n        \nThe lit file name matches in the directory.\n\n        \nOBJECT\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nListFileStream#file:search(filePath)\n\n\n\n\n\n\n\n\nThis will list all the files (also in sub-folders) in a given path.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nListFileStream#file:search(filePath, '.*test3.txt$')\n\n\n\n\n\n\n\n\nThis will list all the files (also in sub-folders) which adheres to a given regex file pattern in a given path.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nListFileStream#file:search(filePath, '.*test3.txt$', true)\n\n\n\n\n\n\n\n\nThis will list all the files excluding the files in sub-folders which adheres to a given regex file pattern in a given path.\n\n\n\n\n\n\nsearchInArchive \n(Stream Function)\n\u00b6\n\n\n\n\nThis.\n\n\n\n\nSyntax\n\n\nfile:searchInArchive(<STRING> uri)\nfile:searchInArchive(<STRING> uri, <STRING> include.by.regexp)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path of the zip or tar file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be searched.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nfileNameList\n\n        \nThe list file names in the archived file.\n\n        \nOBJECT\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nListArchivedFileStream#file:listFilesInArchive(filePath)\n\n\n\n\n\n\n\n\nLists the files inside the compressed file in the given path.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nListArchivedFileStream#file:listFilesInArchive(filePath, '.*test3.txt$')\n\n\n\n\n\n\n\n\nFilters file names adheres to the given regex and lists the files inside the compressed file in the given path.\n\n\n\n\n\n\nunarchive \n(Stream Function)\n\u00b6\n\n\n\n\nThis function decompresses a given file\n\n\n\n\nSyntax\n\n\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri)\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file to be decompressed in the format of zip or tar.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute path of the destination directory.\nNote: If the folder structure does not exist, it will be created.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nThis flag excludes parent folder when extracting the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:unarchive('/User/wso2/source/test.zip', '/User/wso2/destination')\n\n\n\n\n\n\n\n\nUnarchive a zip file in a given path to a given destination.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination')\n\n\n\n\n\n\n\n\nUnarchive a tar file in a given path to a given destination.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nfile:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination', true)\n\n\n\n\n\n\n\n\nUnarchive a tar file in a given path to a given destination excluding the root folder.\n\n\n\n\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.read.wait.timeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.\n\n\n\n\n\n\nEXAMPLE 3\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='csv' @attributes(eof = 'trp:eof', fp = 'trp:file.path'))) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains valid json strings with keys 'symbol' and 'price'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json with additional eof attribute and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\n\n\n\nfileeventlistener \n(Source)\n\u00b6\n\n\n\n\nFileeventlistener provides the functionality for user to get the details of files which have been created or modified or deleted in the execution time.\n\n\n\n\nSyntax\n\n\n@source(type=\"fileeventlistener\", uri=\"<STRING>\", monitoring.interval=\"<STRING>\", file.name.list=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nThis parameter is used to specify a folder to be processed. All the files inside this directory will be processed. This uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmonitoring.interval\n\n        \nThis parameter is used to specify the time interval (in milliseconds) that the process monitor the changes for.\n\n        \n100\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.name.list\n\n        \nThis parameter is used to contain the name of the files which are available in the folder and which has to be monitored.\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='fileeventlistener', uri='file://abc/xyz, file.name.list = 'xyz.txt, test') \ndefine stream FileListenerStream (filepath string, filename string, status string);\n@sink(type='log')\ndefine stream FooStream (filepath string, filename string, status string); \nfrom FileListenerStream\nselect *\ninsert into FooStream;\n\n\n\n\n\n\n\n\nUnder above configuration, An event is triggered if the files in the file.name.list gets created, modified or deleted.\nAn event is created with the filepath, filename and status of the file. Then that will be received by the FooStream..\n\n\n\n\n\n\nEXAMPLE 2\n\n\n@source(type='fileeventlistener',uri='file://abc/xyz') \ndefine stream FileListenerStream (filepath string, filename string, status string);\n@sink(type='log')\ndefine stream FooStream (filepath string, filename string, status string); \nfrom FileListenerStream\nselect *\ninsert into FooStream;\n\n\n\n\n\n\n\n\nUnder above configuration,  An event is triggered if any file under the givenURI gets created, modified or deleted in the execution time. An event is created with the filepath, filename and status of the file.Then that will be received by the FooStream..\n\n\n\n\n\n\nEXAMPLE 3\n\n\n@source(type='fileeventlistener',uri='file://abc/xyz', monitoring.interval='200')\ndefine stream FileListenerStream (filepath string, filename string, status string);\n@sink(type='log')\ndefine stream FooStream (filepath string, filename string, status string);\nfrom FileListenerStream\nselect *\ninsert into FooStream;\n\n\n\n\n\n\n\n\nUnder above configuration, An event is triggered if any file under the given URI gets created, modified or deleted in the execution time. An event is created with the filepath, filename and status of the file. Then that will be received by the FooStream. If there are any changes a new event will be generated in every 200 milliseconds.",
            "title": "2.0.6-SNAPSHOT"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#api-docs-v206-snapshot",
            "text": "Tested Siddhi Core version:  5.1.5  It could also support other Siddhi Core minor versions.",
            "title": "API Docs - v2.0.6-SNAPSHOT"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#file",
            "text": "",
            "title": "File"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#isdirectory-function",
            "text": "This function checks for a given file path points to a directory   Syntax  <BOOL> file:isDirectory(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         The path to be checked for a directory. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isDirectory(filePath) as isDirectory   Checks whether the given path is a directory. Result will be returned as an boolean.",
            "title": "isDirectory (Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#isexist-function",
            "text": "This function checks whether a file or a folder exists in a given path   Syntax  <BOOL> file:isExist(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         File path to check for existence. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isExist('/User/wso2/source/test.txt') as exists   Checks existence of a file in the given path. Result will be returned as an boolean .   EXAMPLE 2  file:isExist('/User/wso2/source/') as exists   Checks existence of a folder in the given path. Result will be returned as an boolean .",
            "title": "isExist (Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#isfile-function",
            "text": "This function checks for a given file path points to a file   Syntax  <BOOL> file:isFile(<STRING> file.path)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.path \n         The path to be checked for a file. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isFile(filePath) as isFile   Checks whether the given path is a file. Result will be returned as an boolean.",
            "title": "isFile (Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#lastmodifiedtime-function",
            "text": "Checks for the last modified time for a given file path   Syntax  <STRING> file:lastModifiedTime(<STRING> uri)\n<STRING> file:lastModifiedTime(<STRING> uri, <STRING> datetime.format)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         File path to be checked for te last modified time. \n         \n         STRING \n         No \n         Yes \n     \n     \n         datetime.format \n         Format of the last modified datetime to be returned. \n         MM/dd/yyyy HH:mm:ss \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  file:lastModifiedTime(filePath) as lastModifiedTime   Last modified datetime of a file will be returned as an string in MM/dd/yyyy HH:mm:ss.   EXAMPLE 2  file:lastModifiedTime(filePath, dd/MM/yyyy HH:mm:ss) as lastModifiedTime   Last modified datetime of a file will be returned as an string in 'dd/MM/yyyy HH:mm:ss' format.",
            "title": "lastModifiedTime (Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#size-function",
            "text": "This function checks for a given file's size   Syntax  <LONG> file:size(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path to the file or directory to be checked for the size. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:size('/User/wso2/source/test.txt') as fileSize   Size of a file in a given path will be returned.",
            "title": "size (Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#archive-stream-function",
            "text": "Archives files and folders as a zip or in tar format that are available in the given file uri.   Syntax  file:archive(<STRING> uri, <STRING> destination.dir.uri)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file or the directory \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute directory path of the the archived file. \n         \n         STRING \n         No \n         Yes \n     \n     \n         archive.type \n         Archive type can be zip or tar \n         zip \n         STRING \n         Yes \n         No \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be archived. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.subdirectories \n         This flag is used to exclude the subdirectories and its files without archiving. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file.zip')   Archives to_be_archived folder in zip format and stores archive_destination folder as file.zip.   EXAMPLE 2  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar')   Archives to_be_archived folder in tar format and stores in archive_destination folder as file.tar.   EXAMPLE 3  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar', '.*test3.txt$')   Archives files which adheres to '.*test3.txt$' regex in to_be_archived folder in tar format and stores in archive_destination folder as file.tar.   EXAMPLE 4  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', '', '', 'false')   Archives to_be_archived folder excluding the sub-folders in zip format and stores in archive_destination folder as file.tar.",
            "title": "archive (Stream Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#copy-stream-function",
            "text": "This function performs copying file from one directory to another.   Syntax  file:copy(<STRING> uri, <STRING> destination.dir.uri)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the File or the directory. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute path of the destination directory. Note: Parent folder structure will be created if it does not exist. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be copied. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.root.dir \n         This flag is used to exclude parent folder when copying the content. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         isSuccess \n         Status of the file copying operation (true if success) \n         BOOL \n       Examples  EXAMPLE 1  InputStream#file:copy('/User/wso2/source/test.txt', 'User/wso2/destination/')   Copies 'test.txt' in 'source' folder to the 'destination' folder.   EXAMPLE 2  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/')   Copies 'source' folder to the 'destination' folder with all its content   EXAMPLE 3  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')   Copies 'source' folder to the 'destination' folder ignoring files doesnt adhere to the given regex.   EXAMPLE 4  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '', true)   Copies only the files resides in 'source' folder to 'destination' folder.",
            "title": "copy (Stream Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#create-stream-function",
            "text": "Create a file or a folder in the given location   Syntax  file:create(<STRING> uri, <STRING> is.directory)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path which needs to be created. \n         \n         STRING \n         No \n         Yes \n     \n     \n         is.directory \n         This flag is used when creating file path is a directory \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  from CreateFileStream#file:create('/User/wso2/source/test.txt', false)   Creates a file in the given path with the name of 'test.txt'.   EXAMPLE 2  from CreateFileStream#file:create('/User/wso2/source/', true)   Creates a folder in the given path with the name of 'source'.",
            "title": "create (Stream Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#delete-stream-function",
            "text": "Deletes file/files in a particular path   Syntax  file:delete(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file or the directory to be deleted. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  from DeleteFileStream#file:delete('/User/wso2/source/test.txt')   Deletes the file in the given path.    EXAMPLE 2  from DeleteFileStream#file:delete('/User/wso2/source/')   Deletes the folder in the given path.",
            "title": "delete (Stream Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#move-stream-function",
            "text": "This function performs copying file from one directory to another.   Syntax  file:move(<STRING> uri, <STRING> destination.dir.uri)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file or directory path. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute file path to the destination directory. Note: Parent folder structure will be created if it does not exist. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be moved. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.root.dir \n         Exclude parent folder when moving the content. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         isSuccess \n         Status of the file moving operation (true if success) \n         BOOL \n       Examples  EXAMPLE 1  InputStream#file:move('/User/wso2/source/test.txt', 'User/wso2/destination/')   Moves 'test.txt' in 'source' folder to the 'destination' folder.   EXAMPLE 2  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/')   Moves 'source' folder to the 'destination' folder with all its content   EXAMPLE 3  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')   Moves 'source' folder to the 'destination' folder excluding files doesnt adhere to the given regex.   EXAMPLE 4  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '', true)   Moves only the files resides in 'source' folder to 'destination' folder.",
            "title": "move (Stream Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#search-stream-function",
            "text": "Searches files in a given folder and lists.   Syntax  file:search(<STRING> uri)\nfile:search(<STRING> uri, <STRING> include.by.regexp)\nfile:search(<STRING> uri, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path of the directory. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be searched. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         Yes \n     \n     \n         exclude.subdirectories \n         This flag is used to exclude the files un subdirectories when listing. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         fileNameList \n         The lit file name matches in the directory. \n         OBJECT \n       Examples  EXAMPLE 1  ListFileStream#file:search(filePath)   This will list all the files (also in sub-folders) in a given path.   EXAMPLE 2  ListFileStream#file:search(filePath, '.*test3.txt$')   This will list all the files (also in sub-folders) which adheres to a given regex file pattern in a given path.   EXAMPLE 3  ListFileStream#file:search(filePath, '.*test3.txt$', true)   This will list all the files excluding the files in sub-folders which adheres to a given regex file pattern in a given path.",
            "title": "search (Stream Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#searchinarchive-stream-function",
            "text": "This.   Syntax  file:searchInArchive(<STRING> uri)\nfile:searchInArchive(<STRING> uri, <STRING> include.by.regexp)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path of the zip or tar file. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be searched. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         fileNameList \n         The list file names in the archived file. \n         OBJECT \n       Examples  EXAMPLE 1  ListArchivedFileStream#file:listFilesInArchive(filePath)   Lists the files inside the compressed file in the given path.   EXAMPLE 2  ListArchivedFileStream#file:listFilesInArchive(filePath, '.*test3.txt$')   Filters file names adheres to the given regex and lists the files inside the compressed file in the given path.",
            "title": "searchInArchive (Stream Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#unarchive-stream-function",
            "text": "This function decompresses a given file   Syntax  file:unarchive(<STRING> uri, <STRING> destination.dir.uri)\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file to be decompressed in the format of zip or tar. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute path of the destination directory. Note: If the folder structure does not exist, it will be created. \n         \n         STRING \n         No \n         Yes \n     \n     \n         exclude.root.dir \n         This flag excludes parent folder when extracting the content. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  file:unarchive('/User/wso2/source/test.zip', '/User/wso2/destination')   Unarchive a zip file in a given path to a given destination.   EXAMPLE 2  file:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination')   Unarchive a tar file in a given path to a given destination.   EXAMPLE 3  file:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination', true)   Unarchive a tar file in a given path to a given destination excluding the root folder.",
            "title": "unarchive (Stream Function)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files   Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);    Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.   Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n     \n     \n         file.read.wait.timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);    Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.   EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.   EXAMPLE 3  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='csv' @attributes(eof = 'trp:eof', fp = 'trp:file.path'))) \ndefine stream FooStream (symbol string, price float, volume long);    Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains valid json strings with keys 'symbol' and 'price'. Once a file is read, its content will be converted to an event using siddhi-map-json with additional eof attribute and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.",
            "title": "file (Source)"
        },
        {
            "location": "/api/2.0.6-SNAPSHOT/#fileeventlistener-source",
            "text": "Fileeventlistener provides the functionality for user to get the details of files which have been created or modified or deleted in the execution time.   Syntax  @source(type=\"fileeventlistener\", uri=\"<STRING>\", monitoring.interval=\"<STRING>\", file.name.list=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         This parameter is used to specify a folder to be processed. All the files inside this directory will be processed. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         monitoring.interval \n         This parameter is used to specify the time interval (in milliseconds) that the process monitor the changes for. \n         100 \n         STRING \n         Yes \n         No \n     \n     \n         file.name.list \n         This parameter is used to contain the name of the files which are available in the folder and which has to be monitored. \n         \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='fileeventlistener', uri='file://abc/xyz, file.name.list = 'xyz.txt, test') \ndefine stream FileListenerStream (filepath string, filename string, status string);\n@sink(type='log')\ndefine stream FooStream (filepath string, filename string, status string); \nfrom FileListenerStream\nselect *\ninsert into FooStream;   Under above configuration, An event is triggered if the files in the file.name.list gets created, modified or deleted. An event is created with the filepath, filename and status of the file. Then that will be received by the FooStream..   EXAMPLE 2  @source(type='fileeventlistener',uri='file://abc/xyz') \ndefine stream FileListenerStream (filepath string, filename string, status string);\n@sink(type='log')\ndefine stream FooStream (filepath string, filename string, status string); \nfrom FileListenerStream\nselect *\ninsert into FooStream;   Under above configuration,  An event is triggered if any file under the givenURI gets created, modified or deleted in the execution time. An event is created with the filepath, filename and status of the file.Then that will be received by the FooStream..   EXAMPLE 3  @source(type='fileeventlistener',uri='file://abc/xyz', monitoring.interval='200')\ndefine stream FileListenerStream (filepath string, filename string, status string);\n@sink(type='log')\ndefine stream FooStream (filepath string, filename string, status string);\nfrom FileListenerStream\nselect *\ninsert into FooStream;   Under above configuration, An event is triggered if any file under the given URI gets created, modified or deleted in the execution time. An event is created with the filepath, filename and status of the file. Then that will be received by the FooStream. If there are any changes a new event will be generated in every 200 milliseconds.",
            "title": "fileeventlistener (Source)"
        },
        {
            "location": "/api/2.0.5/",
            "text": "API Docs - v2.0.5\n\u00b6\n\n\n\n\nTested Siddhi Core version: \n5.1.5\n\n\nIt could also support other Siddhi Core minor versions.\n\n\n\n\nFile\n\u00b6\n\n\nisDirectory \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file path points to a directory\n\n\n\n\nSyntax\n\n\n<BOOL> file:isDirectory(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nThe path to be checked for a directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isDirectory(filePath) as isDirectory\n\n\n\n\n\n\n\n\nChecks whether the given path is a directory. Result will be returned as an boolean.\n\n\n\n\n\n\nisExist \n(Function)\n\u00b6\n\n\n\n\nThis function checks whether a file or a folder exists in a given path\n\n\n\n\nSyntax\n\n\n<BOOL> file:isExist(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nFile path to check for existence.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isExist('/User/wso2/source/test.txt') as exists\n\n\n\n\n\n\n\n\nChecks existence of a file in the given path. Result will be returned as an boolean .\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:isExist('/User/wso2/source/') as exists\n\n\n\n\n\n\n\n\nChecks existence of a folder in the given path. Result will be returned as an boolean .\n\n\n\n\n\n\nisFile \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file path points to a file\n\n\n\n\nSyntax\n\n\n<BOOL> file:isFile(<STRING> file.path)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.path\n\n        \nThe path to be checked for a file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isFile(filePath) as isFile\n\n\n\n\n\n\n\n\nChecks whether the given path is a file. Result will be returned as an boolean.\n\n\n\n\n\n\nlastModifiedTime \n(Function)\n\u00b6\n\n\n\n\nChecks for the last modified time for a given file path\n\n\n\n\nSyntax\n\n\n<STRING> file:lastModifiedTime(<STRING> uri)\n<STRING> file:lastModifiedTime(<STRING> uri, <STRING> datetime.format)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nFile path to be checked for te last modified time.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndatetime.format\n\n        \nFormat of the last modified datetime to be returned.\n\n        \nMM/dd/yyyy HH:mm:ss\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:lastModifiedTime(filePath) as lastModifiedTime\n\n\n\n\n\n\n\n\nLast modified datetime of a file will be returned as an string in MM/dd/yyyy HH:mm:ss.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:lastModifiedTime(filePath, dd/MM/yyyy HH:mm:ss) as lastModifiedTime\n\n\n\n\n\n\n\n\nLast modified datetime of a file will be returned as an string in 'dd/MM/yyyy HH:mm:ss' format.\n\n\n\n\n\n\nsize \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file's size\n\n\n\n\nSyntax\n\n\n<LONG> file:size(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path to the file or directory to be checked for the size.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:size('/User/wso2/source/test.txt') as fileSize\n\n\n\n\n\n\n\n\nSize of a file in a given path will be returned.\n\n\n\n\n\n\narchive \n(Stream Function)\n\u00b6\n\n\n\n\nArchives files and folders as a zip or in tar format that are available in the given file uri.\n\n\n\n\nSyntax\n\n\nfile:archive(<STRING> uri, <STRING> destination.dir.uri)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file or the directory\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute directory path of the the archived file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \narchive.type\n\n        \nArchive type can be zip or tar\n\n        \nzip\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be archived.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.subdirectories\n\n        \nThis flag is used to exclude the subdirectories and its files without archiving.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file.zip')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder in zip format and stores archive_destination folder as file.zip.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder in tar format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar', '.*test3.txt$')\n\n\n\n\n\n\n\n\nArchives files which adheres to '.*test3.txt$' regex in to_be_archived folder in tar format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', '', '', 'false')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder excluding the sub-folders in zip format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\ncopy \n(Stream Function)\n\u00b6\n\n\n\n\nThis function performs copying file from one directory to another.\n\n\n\n\nSyntax\n\n\nfile:copy(<STRING> uri, <STRING> destination.dir.uri)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the File or the directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute path of the destination directory.\nNote: Parent folder structure will be created if it does not exist.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be copied.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nThis flag is used to exclude parent folder when copying the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nisSuccess\n\n        \nStatus of the file copying operation (true if success)\n\n        \nBOOL\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:copy('/User/wso2/source/test.txt', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nCopies 'test.txt' in 'source' folder to the 'destination' folder.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nCopies 'source' folder to the 'destination' folder with all its content\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')\n\n\n\n\n\n\n\n\nCopies 'source' folder to the 'destination' folder ignoring files doesnt adhere to the given regex.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '', true)\n\n\n\n\n\n\n\n\nCopies only the files resides in 'source' folder to 'destination' folder.\n\n\n\n\n\n\ncreate \n(Stream Function)\n\u00b6\n\n\n\n\nCreate a file or a folder in the given location\n\n\n\n\nSyntax\n\n\nfile:create(<STRING> uri, <STRING> is.directory)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path which needs to be created.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nis.directory\n\n        \nThis flag is used when creating file path is a directory\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom CreateFileStream#file:create('/User/wso2/source/test.txt', false)\n\n\n\n\n\n\n\n\nCreates a file in the given path with the name of 'test.txt'.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfrom CreateFileStream#file:create('/User/wso2/source/', true)\n\n\n\n\n\n\n\n\nCreates a folder in the given path with the name of 'source'.\n\n\n\n\n\n\ndelete \n(Stream Function)\n\u00b6\n\n\n\n\nDeletes file/files in a particular path\n\n\n\n\nSyntax\n\n\nfile:delete(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file or the directory to be deleted.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom DeleteFileStream#file:delete('/User/wso2/source/test.txt')\n\n\n\n\n\n\n\n\nDeletes the file in the given path. \n\n\n\n\n\n\nEXAMPLE 2\n\n\nfrom DeleteFileStream#file:delete('/User/wso2/source/')\n\n\n\n\n\n\n\n\nDeletes the folder in the given path. \n\n\n\n\n\n\nmove \n(Stream Function)\n\u00b6\n\n\n\n\nThis function performs copying file from one directory to another.\n\n\n\n\nSyntax\n\n\nfile:move(<STRING> uri, <STRING> destination.dir.uri)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file or directory path.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute file path to the destination directory.\nNote: Parent folder structure will be created if it does not exist.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be moved.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nExclude parent folder when moving the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nisSuccess\n\n        \nStatus of the file moving operation (true if success)\n\n        \nBOOL\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:move('/User/wso2/source/test.txt', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nMoves 'test.txt' in 'source' folder to the 'destination' folder.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nMoves 'source' folder to the 'destination' folder with all its content\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')\n\n\n\n\n\n\n\n\nMoves 'source' folder to the 'destination' folder excluding files doesnt adhere to the given regex.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '', true)\n\n\n\n\n\n\n\n\nMoves only the files resides in 'source' folder to 'destination' folder.\n\n\n\n\n\n\nsearch \n(Stream Function)\n\u00b6\n\n\n\n\nSearches files in a given folder and lists.\n\n\n\n\nSyntax\n\n\nfile:search(<STRING> uri)\nfile:search(<STRING> uri, <STRING> include.by.regexp)\nfile:search(<STRING> uri, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path of the directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be searched.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nYes\n\n    \n\n    \n\n        \nexclude.subdirectories\n\n        \nThis flag is used to exclude the files un subdirectories when listing.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nfileNameList\n\n        \nThe lit file name matches in the directory.\n\n        \nOBJECT\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nListFileStream#file:search(filePath)\n\n\n\n\n\n\n\n\nThis will list all the files (also in sub-folders) in a given path.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nListFileStream#file:search(filePath, '.*test3.txt$')\n\n\n\n\n\n\n\n\nThis will list all the files (also in sub-folders) which adheres to a given regex file pattern in a given path.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nListFileStream#file:search(filePath, '.*test3.txt$', true)\n\n\n\n\n\n\n\n\nThis will list all the files excluding the files in sub-folders which adheres to a given regex file pattern in a given path.\n\n\n\n\n\n\nsearchInArchive \n(Stream Function)\n\u00b6\n\n\n\n\nThis.\n\n\n\n\nSyntax\n\n\nfile:searchInArchive(<STRING> uri)\nfile:searchInArchive(<STRING> uri, <STRING> include.by.regexp)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path of the zip or tar file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be searched.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nfileNameList\n\n        \nThe list file names in the archived file.\n\n        \nOBJECT\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nListArchivedFileStream#file:listFilesInArchive(filePath)\n\n\n\n\n\n\n\n\nLists the files inside the compressed file in the given path.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nListArchivedFileStream#file:listFilesInArchive(filePath, '.*test3.txt$')\n\n\n\n\n\n\n\n\nFilters file names adheres to the given regex and lists the files inside the compressed file in the given path.\n\n\n\n\n\n\nunarchive \n(Stream Function)\n\u00b6\n\n\n\n\nThis function decompresses a given file\n\n\n\n\nSyntax\n\n\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri)\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file to be decompressed in the format of zip or tar.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute path of the destination directory.\nNote: If the folder structure does not exist, it will be created.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nThis flag excludes parent folder when extracting the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:unarchive('/User/wso2/source/test.zip', '/User/wso2/destination')\n\n\n\n\n\n\n\n\nUnarchive a zip file in a given path to a given destination.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination')\n\n\n\n\n\n\n\n\nUnarchive a tar file in a given path to a given destination.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nfile:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination', true)\n\n\n\n\n\n\n\n\nUnarchive a tar file in a given path to a given destination excluding the root folder.\n\n\n\n\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.read.wait.timeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "2.0.5"
        },
        {
            "location": "/api/2.0.5/#api-docs-v205",
            "text": "Tested Siddhi Core version:  5.1.5  It could also support other Siddhi Core minor versions.",
            "title": "API Docs - v2.0.5"
        },
        {
            "location": "/api/2.0.5/#file",
            "text": "",
            "title": "File"
        },
        {
            "location": "/api/2.0.5/#isdirectory-function",
            "text": "This function checks for a given file path points to a directory   Syntax  <BOOL> file:isDirectory(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         The path to be checked for a directory. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isDirectory(filePath) as isDirectory   Checks whether the given path is a directory. Result will be returned as an boolean.",
            "title": "isDirectory (Function)"
        },
        {
            "location": "/api/2.0.5/#isexist-function",
            "text": "This function checks whether a file or a folder exists in a given path   Syntax  <BOOL> file:isExist(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         File path to check for existence. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isExist('/User/wso2/source/test.txt') as exists   Checks existence of a file in the given path. Result will be returned as an boolean .   EXAMPLE 2  file:isExist('/User/wso2/source/') as exists   Checks existence of a folder in the given path. Result will be returned as an boolean .",
            "title": "isExist (Function)"
        },
        {
            "location": "/api/2.0.5/#isfile-function",
            "text": "This function checks for a given file path points to a file   Syntax  <BOOL> file:isFile(<STRING> file.path)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.path \n         The path to be checked for a file. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:isFile(filePath) as isFile   Checks whether the given path is a file. Result will be returned as an boolean.",
            "title": "isFile (Function)"
        },
        {
            "location": "/api/2.0.5/#lastmodifiedtime-function",
            "text": "Checks for the last modified time for a given file path   Syntax  <STRING> file:lastModifiedTime(<STRING> uri)\n<STRING> file:lastModifiedTime(<STRING> uri, <STRING> datetime.format)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         File path to be checked for te last modified time. \n         \n         STRING \n         No \n         Yes \n     \n     \n         datetime.format \n         Format of the last modified datetime to be returned. \n         MM/dd/yyyy HH:mm:ss \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  file:lastModifiedTime(filePath) as lastModifiedTime   Last modified datetime of a file will be returned as an string in MM/dd/yyyy HH:mm:ss.   EXAMPLE 2  file:lastModifiedTime(filePath, dd/MM/yyyy HH:mm:ss) as lastModifiedTime   Last modified datetime of a file will be returned as an string in 'dd/MM/yyyy HH:mm:ss' format.",
            "title": "lastModifiedTime (Function)"
        },
        {
            "location": "/api/2.0.5/#size-function",
            "text": "This function checks for a given file's size   Syntax  <LONG> file:size(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path to the file or directory to be checked for the size. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  file:size('/User/wso2/source/test.txt') as fileSize   Size of a file in a given path will be returned.",
            "title": "size (Function)"
        },
        {
            "location": "/api/2.0.5/#archive-stream-function",
            "text": "Archives files and folders as a zip or in tar format that are available in the given file uri.   Syntax  file:archive(<STRING> uri, <STRING> destination.dir.uri)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file or the directory \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute directory path of the the archived file. \n         \n         STRING \n         No \n         Yes \n     \n     \n         archive.type \n         Archive type can be zip or tar \n         zip \n         STRING \n         Yes \n         No \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be archived. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.subdirectories \n         This flag is used to exclude the subdirectories and its files without archiving. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file.zip')   Archives to_be_archived folder in zip format and stores archive_destination folder as file.zip.   EXAMPLE 2  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar')   Archives to_be_archived folder in tar format and stores in archive_destination folder as file.tar.   EXAMPLE 3  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar', '.*test3.txt$')   Archives files which adheres to '.*test3.txt$' regex in to_be_archived folder in tar format and stores in archive_destination folder as file.tar.   EXAMPLE 4  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', '', '', 'false')   Archives to_be_archived folder excluding the sub-folders in zip format and stores in archive_destination folder as file.tar.",
            "title": "archive (Stream Function)"
        },
        {
            "location": "/api/2.0.5/#copy-stream-function",
            "text": "This function performs copying file from one directory to another.   Syntax  file:copy(<STRING> uri, <STRING> destination.dir.uri)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the File or the directory. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute path of the destination directory. Note: Parent folder structure will be created if it does not exist. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be copied. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.root.dir \n         This flag is used to exclude parent folder when copying the content. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         isSuccess \n         Status of the file copying operation (true if success) \n         BOOL \n       Examples  EXAMPLE 1  InputStream#file:copy('/User/wso2/source/test.txt', 'User/wso2/destination/')   Copies 'test.txt' in 'source' folder to the 'destination' folder.   EXAMPLE 2  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/')   Copies 'source' folder to the 'destination' folder with all its content   EXAMPLE 3  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')   Copies 'source' folder to the 'destination' folder ignoring files doesnt adhere to the given regex.   EXAMPLE 4  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '', true)   Copies only the files resides in 'source' folder to 'destination' folder.",
            "title": "copy (Stream Function)"
        },
        {
            "location": "/api/2.0.5/#create-stream-function",
            "text": "Create a file or a folder in the given location   Syntax  file:create(<STRING> uri, <STRING> is.directory)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path which needs to be created. \n         \n         STRING \n         No \n         Yes \n     \n     \n         is.directory \n         This flag is used when creating file path is a directory \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  from CreateFileStream#file:create('/User/wso2/source/test.txt', false)   Creates a file in the given path with the name of 'test.txt'.   EXAMPLE 2  from CreateFileStream#file:create('/User/wso2/source/', true)   Creates a folder in the given path with the name of 'source'.",
            "title": "create (Stream Function)"
        },
        {
            "location": "/api/2.0.5/#delete-stream-function",
            "text": "Deletes file/files in a particular path   Syntax  file:delete(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file or the directory to be deleted. \n         \n         STRING \n         No \n         Yes \n       Examples  EXAMPLE 1  from DeleteFileStream#file:delete('/User/wso2/source/test.txt')   Deletes the file in the given path.    EXAMPLE 2  from DeleteFileStream#file:delete('/User/wso2/source/')   Deletes the folder in the given path.",
            "title": "delete (Stream Function)"
        },
        {
            "location": "/api/2.0.5/#move-stream-function",
            "text": "This function performs copying file from one directory to another.   Syntax  file:move(<STRING> uri, <STRING> destination.dir.uri)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file or directory path. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute file path to the destination directory. Note: Parent folder structure will be created if it does not exist. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be moved. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.root.dir \n         Exclude parent folder when moving the content. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         isSuccess \n         Status of the file moving operation (true if success) \n         BOOL \n       Examples  EXAMPLE 1  InputStream#file:move('/User/wso2/source/test.txt', 'User/wso2/destination/')   Moves 'test.txt' in 'source' folder to the 'destination' folder.   EXAMPLE 2  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/')   Moves 'source' folder to the 'destination' folder with all its content   EXAMPLE 3  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')   Moves 'source' folder to the 'destination' folder excluding files doesnt adhere to the given regex.   EXAMPLE 4  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '', true)   Moves only the files resides in 'source' folder to 'destination' folder.",
            "title": "move (Stream Function)"
        },
        {
            "location": "/api/2.0.5/#search-stream-function",
            "text": "Searches files in a given folder and lists.   Syntax  file:search(<STRING> uri)\nfile:search(<STRING> uri, <STRING> include.by.regexp)\nfile:search(<STRING> uri, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path of the directory. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be searched. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         Yes \n     \n     \n         exclude.subdirectories \n         This flag is used to exclude the files un subdirectories when listing. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         fileNameList \n         The lit file name matches in the directory. \n         OBJECT \n       Examples  EXAMPLE 1  ListFileStream#file:search(filePath)   This will list all the files (also in sub-folders) in a given path.   EXAMPLE 2  ListFileStream#file:search(filePath, '.*test3.txt$')   This will list all the files (also in sub-folders) which adheres to a given regex file pattern in a given path.   EXAMPLE 3  ListFileStream#file:search(filePath, '.*test3.txt$', true)   This will list all the files excluding the files in sub-folders which adheres to a given regex file pattern in a given path.",
            "title": "search (Stream Function)"
        },
        {
            "location": "/api/2.0.5/#searchinarchive-stream-function",
            "text": "This.   Syntax  file:searchInArchive(<STRING> uri)\nfile:searchInArchive(<STRING> uri, <STRING> include.by.regexp)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path of the zip or tar file. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be searched. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         fileNameList \n         The list file names in the archived file. \n         OBJECT \n       Examples  EXAMPLE 1  ListArchivedFileStream#file:listFilesInArchive(filePath)   Lists the files inside the compressed file in the given path.   EXAMPLE 2  ListArchivedFileStream#file:listFilesInArchive(filePath, '.*test3.txt$')   Filters file names adheres to the given regex and lists the files inside the compressed file in the given path.",
            "title": "searchInArchive (Stream Function)"
        },
        {
            "location": "/api/2.0.5/#unarchive-stream-function",
            "text": "This function decompresses a given file   Syntax  file:unarchive(<STRING> uri, <STRING> destination.dir.uri)\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file to be decompressed in the format of zip or tar. \n         \n         STRING \n         No \n         Yes \n     \n     \n         destination.dir.uri \n         Absolute path of the destination directory. Note: If the folder structure does not exist, it will be created. \n         \n         STRING \n         No \n         Yes \n     \n     \n         exclude.root.dir \n         This flag excludes parent folder when extracting the content. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  file:unarchive('/User/wso2/source/test.zip', '/User/wso2/destination')   Unarchive a zip file in a given path to a given destination.   EXAMPLE 2  file:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination')   Unarchive a tar file in a given path to a given destination.   EXAMPLE 3  file:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination', true)   Unarchive a tar file in a given path to a given destination excluding the root folder.",
            "title": "unarchive (Stream Function)"
        },
        {
            "location": "/api/2.0.5/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/2.0.5/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files   Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);    Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/2.0.5/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/2.0.5/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.   Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n     \n     \n         file.read.wait.timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);    Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.   EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/2.0.4/",
            "text": "API Docs - v2.0.4\n\u00b6\n\n\n\n\nTested Siddhi Core version: \n5.1.5\n\n\nIt could also support other Siddhi Core minor versions.\n\n\n\n\nFile\n\u00b6\n\n\nisDirectory \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file path points to a directory\n\n\n\n\nSyntax\n\n\n<BOOL> file:isDirectory(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nThe path to be checked for a directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isDirectory(filePath) as isDirectory\n\n\n\n\n\n\n\n\nChecks whether the given path is a directory. Result will be returned as an boolean.\n\n\n\n\n\n\nisExist \n(Function)\n\u00b6\n\n\n\n\nThis function checks whether a file or a folder exists in a given path\n\n\n\n\nSyntax\n\n\n<BOOL> file:isExist(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nFile path to check for existence.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isExist('/User/wso2/source/test.txt') as exists\n\n\n\n\n\n\n\n\nChecks existence of a file in the given path. Result will be returned as an boolean .\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:isExist('/User/wso2/source/') as exists\n\n\n\n\n\n\n\n\nChecks existence of a folder in the given path. Result will be returned as an boolean .\n\n\n\n\n\n\nisFile \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file path points to a file\n\n\n\n\nSyntax\n\n\n<BOOL> file:isFile(<STRING> file.path)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.path\n\n        \nThe path to be checked for a file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:isFile(filePath) as isFile\n\n\n\n\n\n\n\n\nChecks whether the given path is a file. Result will be returned as an boolean.\n\n\n\n\n\n\nlastModifiedTime \n(Function)\n\u00b6\n\n\n\n\nChecks for the last modified time for a given file path\n\n\n\n\nSyntax\n\n\n<STRING> file:lastModifiedTime(<STRING> uri)\n<STRING> file:lastModifiedTime(<STRING> uri, <STRING> datetime.format)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nFile path to be checked for te last modified time.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndatetime.format\n\n        \nFormat of the last modified datetime to be returned.\n\n        \nMM/dd/yyyy HH:mm:ss\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:lastModifiedTime(filePath) as lastModifiedTime\n\n\n\n\n\n\n\n\nLast modified datetime of a file will be returned as an string in MM/dd/yyyy HH:mm:ss.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:lastModifiedTime(filePath, dd/MM/yyyy HH:mm:ss) as lastModifiedTime\n\n\n\n\n\n\n\n\nLast modified datetime of a file will be returned as an string in 'dd/MM/yyyy HH:mm:ss' format.\n\n\n\n\n\n\nsize \n(Function)\n\u00b6\n\n\n\n\nThis function checks for a given file's size\n\n\n\n\nSyntax\n\n\n<LONG> file:size(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path to the file or directory to be checked for the size.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:size('/User/wso2/source/test.txt') as fileSize\n\n\n\n\n\n\n\n\nSize of a file in a given path will be returned.\n\n\n\n\n\n\narchive \n(Stream Function)\n\u00b6\n\n\n\n\nArchives files and folders as a zip or in tar format that are available in the given file uri.\n\n\n\n\nSyntax\n\n\nfile:archive(<STRING> uri, <STRING> destination.dir.uri)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file or the directory\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute directory path of the the archived file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \narchive.type\n\n        \nArchive type can be zip or tar\n\n        \nzip\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be archived.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.subdirectories\n\n        \nThis flag is used to exclude the subdirectories and its files without archiving.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file.zip')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder in zip format and stores archive_destination folder as file.zip.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder in tar format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar', '.*test3.txt$')\n\n\n\n\n\n\n\n\nArchives files which adheres to '.*test3.txt$' regex in to_be_archived folder in tar format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', '', '', 'false')\n\n\n\n\n\n\n\n\nArchives to_be_archived folder excluding the sub-folders in zip format and stores in archive_destination folder as file.tar.\n\n\n\n\n\n\ncopy \n(Stream Function)\n\u00b6\n\n\n\n\nThis function performs copying file from one directory to another.\n\n\n\n\nSyntax\n\n\nfile:copy(<STRING> uri, <STRING> destination.dir.uri)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the File or the directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute path of the destination directory.\nNote: Parent folder structure will be created if it does not exist.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be copied.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nThis flag is used to exclude parent folder when copying the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nisSuccess\n\n        \nStatus of the file copying operation (true if success)\n\n        \nBOOL\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:copy('/User/wso2/source/test.txt', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nCopies 'test.txt' in 'source' folder to the 'destination' folder.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nCopies 'source' folder to the 'destination' folder with all its content\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')\n\n\n\n\n\n\n\n\nCopies 'source' folder to the 'destination' folder ignoring files doesnt adhere to the given regex.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '', true)\n\n\n\n\n\n\n\n\nCopies only the files resides in 'source' folder to 'destination' folder.\n\n\n\n\n\n\ncreate \n(Stream Function)\n\u00b6\n\n\n\n\nCreate a file or a folder in the given location\n\n\n\n\nSyntax\n\n\nfile:create(<STRING> uri, <STRING> is.directory)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path which needs to be created.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nis.directory\n\n        \nThis flag is used when creating file path is a directory\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom CreateFileStream#file:create('/User/wso2/source/test.txt', false)\n\n\n\n\n\n\n\n\nCreates a file in the given path with the name of 'test.txt'.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfrom CreateFileStream#file:create('/User/wso2/source/', true)\n\n\n\n\n\n\n\n\nCreates a folder in the given path with the name of 'source'.\n\n\n\n\n\n\ndelete \n(Stream Function)\n\u00b6\n\n\n\n\nDeletes file/files in a particular path\n\n\n\n\nSyntax\n\n\nfile:delete(<STRING> uri)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file or the directory to be deleted.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfrom DeleteFileStream#file:delete('/User/wso2/source/test.txt')\n\n\n\n\n\n\n\n\nDeletes the file in the given path. \n\n\n\n\n\n\nEXAMPLE 2\n\n\nfrom DeleteFileStream#file:delete('/User/wso2/source/')\n\n\n\n\n\n\n\n\nDeletes the folder in the given path. \n\n\n\n\n\n\nmove \n(Stream Function)\n\u00b6\n\n\n\n\nThis function performs copying file from one directory to another.\n\n\n\n\nSyntax\n\n\nfile:move(<STRING> uri, <STRING> destination.dir.uri)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file or directory path.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute file path to the destination directory.\nNote: Parent folder structure will be created if it does not exist.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be moved.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nExclude parent folder when moving the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nisSuccess\n\n        \nStatus of the file moving operation (true if success)\n\n        \nBOOL\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nInputStream#file:move('/User/wso2/source/test.txt', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nMoves 'test.txt' in 'source' folder to the 'destination' folder.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/')\n\n\n\n\n\n\n\n\nMoves 'source' folder to the 'destination' folder with all its content\n\n\n\n\n\n\nEXAMPLE 3\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')\n\n\n\n\n\n\n\n\nMoves 'source' folder to the 'destination' folder excluding files doesnt adhere to the given regex.\n\n\n\n\n\n\nEXAMPLE 4\n\n\nInputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '', true)\n\n\n\n\n\n\n\n\nMoves only the files resides in 'source' folder to 'destination' folder.\n\n\n\n\n\n\nsearch \n(Stream Function)\n\u00b6\n\n\n\n\nSearches files in a given folder and lists.\n\n\n\n\nSyntax\n\n\nfile:search(<STRING> uri)\nfile:search(<STRING> uri, <STRING> include.by.regexp)\nfile:search(<STRING> uri, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path of the directory.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be searched.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nYes\n\n    \n\n    \n\n        \nexclude.subdirectories\n\n        \nThis flag is used to exclude the files un subdirectories when listing.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nfileNameList\n\n        \nThe lit file name matches in the directory.\n\n        \nOBJECT\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nListFileStream#file:search(filePath)\n\n\n\n\n\n\n\n\nThis will list all the files (also in sub-folders) in a given path.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nListFileStream#file:search(filePath, '.*test3.txt$')\n\n\n\n\n\n\n\n\nThis will list all the files (also in sub-folders) which adheres to a given regex file pattern in a given path.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nListFileStream#file:search(filePath, '.*test3.txt$', true)\n\n\n\n\n\n\n\n\nThis will list all the files excluding the files in sub-folders which adheres to a given regex file pattern in a given path.\n\n\n\n\n\n\nsearchInArchive \n(Stream Function)\n\u00b6\n\n\n\n\nThis.\n\n\n\n\nSyntax\n\n\nfile:searchInArchive(<STRING> uri)\nfile:searchInArchive(<STRING> uri, <STRING> include.by.regexp)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute file path of the zip or tar file.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \ninclude.by.regexp\n\n        \nOnly the files matching the patterns will be searched.\nNote: Add an empty string to match all files\n\n        \n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExtra Return Attributes\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nPossible Types\n\n    \n\n    \n\n        \nfileNameList\n\n        \nThe list file names in the archived file.\n\n        \nOBJECT\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nListArchivedFileStream#file:listFilesInArchive(filePath)\n\n\n\n\n\n\n\n\nLists the files inside the compressed file in the given path.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nListArchivedFileStream#file:listFilesInArchive(filePath, '.*test3.txt$')\n\n\n\n\n\n\n\n\nFilters file names adheres to the given regex and lists the files inside the compressed file in the given path.\n\n\n\n\n\n\nunarchive \n(Stream Function)\n\u00b6\n\n\n\n\nThis function decompresses a given file\n\n\n\n\nSyntax\n\n\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri)\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri, <BOOL> exclude.root.dir)\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nuri\n\n        \nAbsolute path of the file to be decompressed in the format of zip or tar.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \ndestination.dir.uri\n\n        \nAbsolute path of the destination directory.\nNote: If the folder structure does not exist, it will be created.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nexclude.root.dir\n\n        \nThis flag excludes parent folder when extracting the content.\n\n        \nfalse\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\nfile:unarchive('/User/wso2/source/test.zip', '/User/wso2/destination')\n\n\n\n\n\n\n\n\nUnarchive a zip file in a given path to a given destination.\n\n\n\n\n\n\nEXAMPLE 2\n\n\nfile:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination')\n\n\n\n\n\n\n\n\nUnarchive a tar file in a given path to a given destination.\n\n\n\n\n\n\nEXAMPLE 3\n\n\nfile:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination', true)\n\n\n\n\n\n\n\n\nUnarchive a tar file in a given path to a given destination excluding the root folder.\n\n\n\n\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.read.wait.timeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "2.0.4"
        },
        {
            "location": "/api/2.0.4/#api-docs-v204",
            "text": "Tested Siddhi Core version:  5.1.5  It could also support other Siddhi Core minor versions.",
            "title": "API Docs - v2.0.4"
        },
        {
            "location": "/api/2.0.4/#file",
            "text": "",
            "title": "File"
        },
        {
            "location": "/api/2.0.4/#isdirectory-function",
            "text": "This function checks for a given file path points to a directory   Syntax  <BOOL> file:isDirectory(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         The path to be checked for a directory. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  file:isDirectory(filePath) as isDirectory   Checks whether the given path is a directory. Result will be returned as an boolean.",
            "title": "isDirectory (Function)"
        },
        {
            "location": "/api/2.0.4/#isexist-function",
            "text": "This function checks whether a file or a folder exists in a given path   Syntax  <BOOL> file:isExist(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         File path to check for existence. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  file:isExist('/User/wso2/source/test.txt') as exists   Checks existence of a file in the given path. Result will be returned as an boolean .   EXAMPLE 2  file:isExist('/User/wso2/source/') as exists   Checks existence of a folder in the given path. Result will be returned as an boolean .",
            "title": "isExist (Function)"
        },
        {
            "location": "/api/2.0.4/#isfile-function",
            "text": "This function checks for a given file path points to a file   Syntax  <BOOL> file:isFile(<STRING> file.path)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.path \n         The path to be checked for a file. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  file:isFile(filePath) as isFile   Checks whether the given path is a file. Result will be returned as an boolean.",
            "title": "isFile (Function)"
        },
        {
            "location": "/api/2.0.4/#lastmodifiedtime-function",
            "text": "Checks for the last modified time for a given file path   Syntax  <STRING> file:lastModifiedTime(<STRING> uri)\n<STRING> file:lastModifiedTime(<STRING> uri, <STRING> datetime.format)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         File path to be checked for te last modified time. \n         \n         STRING \n         No \n         No \n     \n     \n         datetime.format \n         Format of the last modified datetime to be returned. \n         MM/dd/yyyy HH:mm:ss \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  file:lastModifiedTime(filePath) as lastModifiedTime   Last modified datetime of a file will be returned as an string in MM/dd/yyyy HH:mm:ss.   EXAMPLE 2  file:lastModifiedTime(filePath, dd/MM/yyyy HH:mm:ss) as lastModifiedTime   Last modified datetime of a file will be returned as an string in 'dd/MM/yyyy HH:mm:ss' format.",
            "title": "lastModifiedTime (Function)"
        },
        {
            "location": "/api/2.0.4/#size-function",
            "text": "This function checks for a given file's size   Syntax  <LONG> file:size(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path to the file or directory to be checked for the size. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  file:size('/User/wso2/source/test.txt') as fileSize   Size of a file in a given path will be returned.",
            "title": "size (Function)"
        },
        {
            "location": "/api/2.0.4/#archive-stream-function",
            "text": "Archives files and folders as a zip or in tar format that are available in the given file uri.   Syntax  file:archive(<STRING> uri, <STRING> destination.dir.uri)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp)\nfile:archive(<STRING> uri, <STRING> destination.dir.uri, <STRING> archive.type, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file or the directory \n         \n         STRING \n         No \n         No \n     \n     \n         destination.dir.uri \n         Absolute directory path of the the archived file. \n         \n         STRING \n         No \n         No \n     \n     \n         archive.type \n         Archive type can be zip or tar \n         zip \n         STRING \n         Yes \n         No \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be archived. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.subdirectories \n         This flag is used to exclude the subdirectories and its files without archiving. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file.zip')   Archives to_be_archived folder in zip format and stores archive_destination folder as file.zip.   EXAMPLE 2  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar')   Archives to_be_archived folder in tar format and stores in archive_destination folder as file.tar.   EXAMPLE 3  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', 'tar', '.*test3.txt$')   Archives files which adheres to '.*test3.txt$' regex in to_be_archived folder in tar format and stores in archive_destination folder as file.tar.   EXAMPLE 4  InputStream#file:archive('/User/wso2/to_be_archived', '/User/wso2/archive_destination/file', '', '', 'false')   Archives to_be_archived folder excluding the sub-folders in zip format and stores in archive_destination folder as file.tar.",
            "title": "archive (Stream Function)"
        },
        {
            "location": "/api/2.0.4/#copy-stream-function",
            "text": "This function performs copying file from one directory to another.   Syntax  file:copy(<STRING> uri, <STRING> destination.dir.uri)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:copy(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the File or the directory. \n         \n         STRING \n         No \n         No \n     \n     \n         destination.dir.uri \n         Absolute path of the destination directory. Note: Parent folder structure will be created if it does not exist. \n         \n         STRING \n         No \n         No \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be copied. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.root.dir \n         This flag is used to exclude parent folder when copying the content. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         isSuccess \n         Status of the file copying operation (true if success) \n         BOOL \n       Examples  EXAMPLE 1  InputStream#file:copy('/User/wso2/source/test.txt', 'User/wso2/destination/')   Copies 'test.txt' in 'source' folder to the 'destination' folder.   EXAMPLE 2  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/')   Copies 'source' folder to the 'destination' folder with all its content   EXAMPLE 3  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')   Copies 'source' folder to the 'destination' folder ignoring files doesnt adhere to the given regex.   EXAMPLE 4  InputStream#file:copy('/User/wso2/source/', 'User/wso2/destination/', '', true)   Copies only the files resides in 'source' folder to 'destination' folder.",
            "title": "copy (Stream Function)"
        },
        {
            "location": "/api/2.0.4/#create-stream-function",
            "text": "Create a file or a folder in the given location   Syntax  file:create(<STRING> uri, <STRING> is.directory)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path which needs to be created. \n         \n         STRING \n         No \n         No \n     \n     \n         is.directory \n         This flag is used when creating file path is a directory \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from CreateFileStream#file:create('/User/wso2/source/test.txt', false)   Creates a file in the given path with the name of 'test.txt'.   EXAMPLE 2  from CreateFileStream#file:create('/User/wso2/source/', true)   Creates a folder in the given path with the name of 'source'.",
            "title": "create (Stream Function)"
        },
        {
            "location": "/api/2.0.4/#delete-stream-function",
            "text": "Deletes file/files in a particular path   Syntax  file:delete(<STRING> uri)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file or the directory to be deleted. \n         \n         STRING \n         No \n         No \n       Examples  EXAMPLE 1  from DeleteFileStream#file:delete('/User/wso2/source/test.txt')   Deletes the file in the given path.    EXAMPLE 2  from DeleteFileStream#file:delete('/User/wso2/source/')   Deletes the folder in the given path.",
            "title": "delete (Stream Function)"
        },
        {
            "location": "/api/2.0.4/#move-stream-function",
            "text": "This function performs copying file from one directory to another.   Syntax  file:move(<STRING> uri, <STRING> destination.dir.uri)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp)\nfile:move(<STRING> uri, <STRING> destination.dir.uri, <STRING> include.by.regexp, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file or directory path. \n         \n         STRING \n         No \n         No \n     \n     \n         destination.dir.uri \n         Absolute file path to the destination directory. Note: Parent folder structure will be created if it does not exist. \n         \n         STRING \n         No \n         No \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be moved. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n     \n     \n         exclude.root.dir \n         Exclude parent folder when moving the content. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         isSuccess \n         Status of the file moving operation (true if success) \n         BOOL \n       Examples  EXAMPLE 1  InputStream#file:move('/User/wso2/source/test.txt', 'User/wso2/destination/')   Moves 'test.txt' in 'source' folder to the 'destination' folder.   EXAMPLE 2  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/')   Moves 'source' folder to the 'destination' folder with all its content   EXAMPLE 3  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '.*test3.txt$')   Moves 'source' folder to the 'destination' folder excluding files doesnt adhere to the given regex.   EXAMPLE 4  InputStream#file:move('/User/wso2/source/', 'User/wso2/destination/', '', true)   Moves only the files resides in 'source' folder to 'destination' folder.",
            "title": "move (Stream Function)"
        },
        {
            "location": "/api/2.0.4/#search-stream-function",
            "text": "Searches files in a given folder and lists.   Syntax  file:search(<STRING> uri)\nfile:search(<STRING> uri, <STRING> include.by.regexp)\nfile:search(<STRING> uri, <STRING> include.by.regexp, <BOOL> exclude.subdirectories)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path of the directory. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be searched. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         Yes \n     \n     \n         exclude.subdirectories \n         This flag is used to exclude the files un subdirectories when listing. \n         false \n         BOOL \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         fileNameList \n         The lit file name matches in the directory. \n         OBJECT \n       Examples  EXAMPLE 1  ListFileStream#file:search(filePath)   This will list all the files (also in sub-folders) in a given path.   EXAMPLE 2  ListFileStream#file:search(filePath, '.*test3.txt$')   This will list all the files (also in sub-folders) which adheres to a given regex file pattern in a given path.   EXAMPLE 3  ListFileStream#file:search(filePath, '.*test3.txt$', true)   This will list all the files excluding the files in sub-folders which adheres to a given regex file pattern in a given path.",
            "title": "search (Stream Function)"
        },
        {
            "location": "/api/2.0.4/#searchinarchive-stream-function",
            "text": "This.   Syntax  file:searchInArchive(<STRING> uri)\nfile:searchInArchive(<STRING> uri, <STRING> include.by.regexp)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute file path of the zip or tar file. \n         \n         STRING \n         No \n         Yes \n     \n     \n         include.by.regexp \n         Only the files matching the patterns will be searched. Note: Add an empty string to match all files \n         \n         STRING \n         Yes \n         No \n       Extra Return Attributes  \n     \n         Name \n         Description \n         Possible Types \n     \n     \n         fileNameList \n         The list file names in the archived file. \n         OBJECT \n       Examples  EXAMPLE 1  ListArchivedFileStream#file:listFilesInArchive(filePath)   Lists the files inside the compressed file in the given path.   EXAMPLE 2  ListArchivedFileStream#file:listFilesInArchive(filePath, '.*test3.txt$')   Filters file names adheres to the given regex and lists the files inside the compressed file in the given path.",
            "title": "searchInArchive (Stream Function)"
        },
        {
            "location": "/api/2.0.4/#unarchive-stream-function",
            "text": "This function decompresses a given file   Syntax  file:unarchive(<STRING> uri, <STRING> destination.dir.uri)\nfile:unarchive(<STRING> uri, <STRING> destination.dir.uri, <BOOL> exclude.root.dir)  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         uri \n         Absolute path of the file to be decompressed in the format of zip or tar. \n         \n         STRING \n         No \n         No \n     \n     \n         destination.dir.uri \n         Absolute path of the destination directory. Note: If the folder structure does not exist, it will be created. \n         \n         STRING \n         No \n         No \n     \n     \n         exclude.root.dir \n         This flag excludes parent folder when extracting the content. \n         false \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  file:unarchive('/User/wso2/source/test.zip', '/User/wso2/destination')   Unarchive a zip file in a given path to a given destination.   EXAMPLE 2  file:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination')   Unarchive a tar file in a given path to a given destination.   EXAMPLE 3  file:unarchive('/User/wso2/source/test.tar', '/User/wso2/destination', true)   Unarchive a tar file in a given path to a given destination excluding the root folder.",
            "title": "unarchive (Stream Function)"
        },
        {
            "location": "/api/2.0.4/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/2.0.4/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files   Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);    Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/2.0.4/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/2.0.4/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.   Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n     \n     \n         file.read.wait.timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);    Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.   EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/2.0.3/",
            "text": "API Docs - v2.0.3\n\u00b6\n\n\n\n\nTested Siddhi Core version: \n5.1.5\n\n\nIt could also support other Siddhi Core minor versions.\n\n\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.read.wait.timeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "2.0.3"
        },
        {
            "location": "/api/2.0.3/#api-docs-v203",
            "text": "Tested Siddhi Core version:  5.1.5  It could also support other Siddhi Core minor versions.",
            "title": "API Docs - v2.0.3"
        },
        {
            "location": "/api/2.0.3/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/2.0.3/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files   Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);    Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/2.0.3/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/2.0.3/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.   Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n     \n     \n         file.read.wait.timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);    Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.   EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/2.0.2/",
            "text": "API Docs - v2.0.2\n\u00b6\n\n\n\n\nTested Siddhi Core version: \n5.1.5\n\n\nIt could also support other Siddhi Core minor versions.\n\n\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.read.wait.timeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "2.0.2"
        },
        {
            "location": "/api/2.0.2/#api-docs-v202",
            "text": "Tested Siddhi Core version:  5.1.5  It could also support other Siddhi Core minor versions.",
            "title": "API Docs - v2.0.2"
        },
        {
            "location": "/api/2.0.2/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/2.0.2/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files   Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);    Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/2.0.2/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/2.0.2/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.   Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", file.read.wait.timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n     \n     \n         file.read.wait.timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  till it waits before retrying to read the full file content. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);    Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.   EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/2.0.1/",
            "text": "API Docs - v2.0.1\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "2.0.1"
        },
        {
            "location": "/api/2.0.1/#api-docs-v201",
            "text": "",
            "title": "API Docs - v2.0.1"
        },
        {
            "location": "/api/2.0.1/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/2.0.1/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/2.0.1/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/2.0.1/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/2.0.0/",
            "text": "API Docs - v2.0.0\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "2.0.0"
        },
        {
            "location": "/api/2.0.0/#api-docs-v200",
            "text": "",
            "title": "API Docs - v2.0.0"
        },
        {
            "location": "/api/2.0.0/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/2.0.0/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/2.0.0/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/2.0.0/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.1.1/",
            "text": "API Docs - v1.1.1\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.1.1"
        },
        {
            "location": "/api/1.1.1/#api-docs-v111",
            "text": "",
            "title": "API Docs - v1.1.1"
        },
        {
            "location": "/api/1.1.1/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.1.1/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.1.1/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.1.1/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.1.0/",
            "text": "API Docs - v1.1.0\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.1.0"
        },
        {
            "location": "/api/1.1.0/#api-docs-v110",
            "text": "",
            "title": "API Docs - v1.1.0"
        },
        {
            "location": "/api/1.1.0/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.1.0/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.1.0/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.1.0/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.14/",
            "text": "API Docs - v1.0.14\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.14"
        },
        {
            "location": "/api/1.0.14/#api-docs-v1014",
            "text": "",
            "title": "API Docs - v1.0.14"
        },
        {
            "location": "/api/1.0.14/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.14/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.14/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.14/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.13/",
            "text": "API Docs - v1.0.13\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.13"
        },
        {
            "location": "/api/1.0.13/#api-docs-v1013",
            "text": "",
            "title": "API Docs - v1.0.13"
        },
        {
            "location": "/api/1.0.13/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.13/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.13/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.13/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.12/",
            "text": "API Docs - v1.0.12\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.12"
        },
        {
            "location": "/api/1.0.12/#api-docs-v1012",
            "text": "",
            "title": "API Docs - v1.0.12"
        },
        {
            "location": "/api/1.0.12/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.12/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.12/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.12/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.11/",
            "text": "API Docs - v1.0.11\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.11"
        },
        {
            "location": "/api/1.0.11/#api-docs-v1011",
            "text": "",
            "title": "API Docs - v1.0.11"
        },
        {
            "location": "/api/1.0.11/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.11/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.11/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.11/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.10/",
            "text": "API Docs - v1.0.10\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.10"
        },
        {
            "location": "/api/1.0.10/#api-docs-v1010",
            "text": "",
            "title": "API Docs - v1.0.10"
        },
        {
            "location": "/api/1.0.10/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.10/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.10/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.10/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.9/",
            "text": "API Docs - v1.0.9\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nadd.line.separator\n\n        \nThis parameter is used to specify whether events added to the file should be separated by a newline.\nIf add.event.separator= 'true',then a newline will be added after data is added to the file.\n\n        \ntrue. (However, if csv mapper is used, it is false)\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.9"
        },
        {
            "location": "/api/1.0.9/#api-docs-v109",
            "text": "",
            "title": "API Docs - v1.0.9"
        },
        {
            "location": "/api/1.0.9/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.9/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", add.line.separator=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         add.line.separator \n         This parameter is used to specify whether events added to the file should be separated by a newline. If add.event.separator= 'true',then a newline will be added after data is added to the file. \n         true. (However, if csv mapper is used, it is false) \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.9/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.9/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.8/",
            "text": "API Docs - v1.0.8\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.8"
        },
        {
            "location": "/api/1.0.8/#api-docs-v108",
            "text": "",
            "title": "API Docs - v1.0.8"
        },
        {
            "location": "/api/1.0.8/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.8/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.8/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.8/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.7/",
            "text": "API Docs - v1.0.7\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.7"
        },
        {
            "location": "/api/1.0.7/#api-docs-v107",
            "text": "",
            "title": "API Docs - v1.0.7"
        },
        {
            "location": "/api/1.0.7/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.7/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.7/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.7/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.6/",
            "text": "API Docs - v1.0.6\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.6"
        },
        {
            "location": "/api/1.0.6/#api-docs-v106",
            "text": "",
            "title": "API Docs - v1.0.6"
        },
        {
            "location": "/api/1.0.6/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.6/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.6/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.6/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.5/",
            "text": "API Docs - v1.0.5\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.5"
        },
        {
            "location": "/api/1.0.5/#api-docs-v105",
            "text": "",
            "title": "API Docs - v1.0.5"
        },
        {
            "location": "/api/1.0.5/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.5/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.5/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.5/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.4/",
            "text": "API Docs - v1.0.4\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.4"
        },
        {
            "location": "/api/1.0.4/#api-docs-v104",
            "text": "",
            "title": "API Docs - v1.0.4"
        },
        {
            "location": "/api/1.0.4/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.4/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.4/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.4/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.3/",
            "text": "API Docs - v1.0.3\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.3"
        },
        {
            "location": "/api/1.0.3/#api-docs-v103",
            "text": "",
            "title": "API Docs - v1.0.3"
        },
        {
            "location": "/api/1.0.3/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.3/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.3/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.3/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.2/",
            "text": "API Docs - v1.0.2\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.2"
        },
        {
            "location": "/api/1.0.2/#api-docs-v102",
            "text": "",
            "title": "API Docs - v1.0.2"
        },
        {
            "location": "/api/1.0.2/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.2/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.2/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.2/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.1/",
            "text": "API Docs - v1.0.1\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\nThis uri MUST have the respective protocol specified.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntimeout\n\n        \nThis parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed.\n\n        \n5000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.1"
        },
        {
            "location": "/api/1.0.1/#api-docs-v101",
            "text": "",
            "title": "API Docs - v1.0.1"
        },
        {
            "location": "/api/1.0.1/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.1/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.1/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.1/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", timeout=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. This uri MUST have the respective protocol specified. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         timeout \n         This parameter is used to specify the maximum time period (in milliseconds)  for waiting until a file is processed. \n         5000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='file://abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='file://abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.0-M12/",
            "text": "API Docs - v1.0.0-M12\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='/abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='/abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.0-M12"
        },
        {
            "location": "/api/1.0.0-M12/#api-docs-v100-m12",
            "text": "",
            "title": "API Docs - v1.0.0-M12"
        },
        {
            "location": "/api/1.0.0-M12/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.0-M12/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.0-M12/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.0-M12/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='/abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='/abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.0-M11/",
            "text": "API Docs - v1.0.0-M11\n\u00b6\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='/abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='/abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.\n\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}",
            "title": "1.0.0-M11"
        },
        {
            "location": "/api/1.0.0-M11/#api-docs-v100-m11",
            "text": "",
            "title": "API Docs - v1.0.0-M11"
        },
        {
            "location": "/api/1.0.0-M11/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.0-M11/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='/abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='/abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.0-M11/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.0-M11/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.0-M10/",
            "text": "API Docs - v1.0.0-M10\n\u00b6\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='/abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='/abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.\n\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}",
            "title": "1.0.0-M10"
        },
        {
            "location": "/api/1.0.0-M10/#api-docs-v100-m10",
            "text": "",
            "title": "API Docs - v1.0.0-M10"
        },
        {
            "location": "/api/1.0.0-M10/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.0-M10/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='/abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='/abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        },
        {
            "location": "/api/1.0.0-M10/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.0-M10/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.0/",
            "text": "API Docs - v1.0.0\n\u00b6\n\n\nSink\n\u00b6\n\n\nfile \n(Sink)\n\u00b6\n\n\nFile Sink can be used to publish (write) event data which is processed within siddhi to files. \nSiddhi-io-file sink provides support to write both textual and binary data into files\n\n\n\nSyntax\n\n\n@sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify the file for data to be written. \n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nYes\n\n    \n\n    \n\n        \nappend\n\n        \nThis parameter is used to specify whether the data should be append to the file or not.\nIf append = 'true', data will be write at the end of the file without changing the existing content.\nIf file does not exist, a new fill will be crated and then data will be written.\nIf append append = 'false', \nIf given file exists, existing content will be deleted and then data will be written back to the file.\nIf given file does not exist, a new file will be created and then data will be written on it.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below.\n{\n\u00a0\u00a0\u00a0\u00a0\"event\":{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\",\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100\n\u00a0\u00a0\u00a0\u00a0}\n}\n\n\n\nSource\n\u00b6\n\n\nfile \n(Source)\n\u00b6\n\n\nFile Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.\n\n\n\nSyntax\n\n\n@source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", @map(...)))\n\n\n\n\n\nQUERY PARAMETERS\n\n\n\n    \n\n        \nName\n\n        \nDescription\n\n        \nDefault Value\n\n        \nPossible Data Types\n\n        \nOptional\n\n        \nDynamic\n\n    \n\n    \n\n        \ndir.uri\n\n        \nUsed to specify a directory to be processed. \nAll the files inside this directory will be processed. \nOnly one of 'dir.uri' and 'file.uri' should be provided.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nfile.uri\n\n        \nUsed to specify a file to be processed. \n\u00a0Only one of 'dir.uri' and 'file.uri' should be provided.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmode\n\n        \nThis parameter is used to specify how files in given directory should.Possible values for this parameter are,\n1. TEXT.FULL : to read a text file completely at once.\n2. BINARY.FULL : to read a binary file completely at once.\n3. LINE : to read a text file line by line.\n4. REGEX : to read a text file and extract data using a regex.\n\n        \nline\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ntailing\n\n        \nThis can either have value true or false. By default it will be true. \nThis attribute allows user to specify whether the file should be tailed or not. \nIf tailing is enabled, the first file of the directory will be tailed.\nAlso tailing should not be enabled in 'binary.full' or 'text.full' modes.\n\n        \ntrue\n\n        \nBOOL\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.process\n\n        \nThis parameter is used to specify the action which should be carried out \nafter processing a file in the given directory. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\n\n        \ndelete\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \naction.after.failure\n\n        \nThis parameter is used to specify the action which should be carried out if a failure occurred during the process. \nIt can be either DELETE or MOVE and default value will be 'DELETE'.\nIf the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.process\n\n        \nIf action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nmove.after.failure\n\n        \nIf action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter.\nThis should be the absolute path of the file that going to be created after moving is done.\n\n        \n\n        \nSTRING\n\n        \nNo\n\n        \nNo\n\n    \n\n    \n\n        \nbegin.regex\n\n        \nThis will define the regex to be matched at the beginning of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nend.regex\n\n        \nThis will define the regex to be matched at the end of the retrieved content.\n\n        \nNone\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \nfile.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a file.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n    \n\n        \ndir.polling.interval\n\n        \nThis parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory.\n\n        \n1000\n\n        \nSTRING\n\n        \nYes\n\n        \nNo\n\n    \n\n\n\n\nExamples\n\n\nEXAMPLE 1\n\n\n@source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='/abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long); \n\n\n\n\n\nUnder above configuration, all the files in directory will be picked and read one by one.\nIn this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'.\nOnce a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nFinally, after reading is finished, the file will be deleted.\n\n\n\nEXAMPLE 2\n\n\n@source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='/abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);\n\n\n\n\n\nUnder above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line.\nIn this case, it is assumed that the file contains lines json strings.\nFor each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream.\nOnce file content is completely read, it will keep checking whether a new entry is added to the file or not.\nIf such entry is added, it will be immediately picked up and processed.",
            "title": "1.0.0"
        },
        {
            "location": "/api/1.0.0/#api-docs-v100",
            "text": "",
            "title": "API Docs - v1.0.0"
        },
        {
            "location": "/api/1.0.0/#sink",
            "text": "",
            "title": "Sink"
        },
        {
            "location": "/api/1.0.0/#file-sink",
            "text": "File Sink can be used to publish (write) event data which is processed within siddhi to files.  Siddhi-io-file sink provides support to write both textual and binary data into files  Syntax  @sink(type=\"file\", file.uri=\"<STRING>\", append=\"<BOOL>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         file.uri \n         Used to specify the file for data to be written.  \n         \n         STRING \n         No \n         Yes \n     \n     \n         append \n         This parameter is used to specify whether the data should be append to the file or not. If append = 'true', data will be write at the end of the file without changing the existing content. If file does not exist, a new fill will be crated and then data will be written. If append append = 'false',  If given file exists, existing content will be deleted and then data will be written back to the file. If given file does not exist, a new file will be created and then data will be written on it. \n         true \n         BOOL \n         Yes \n         No \n       Examples  EXAMPLE 1  @sink(type='file', @map(type='json'), append='false', file.uri='/abc/{{symbol}}.txt') define stream BarStream (symbol string, price float, volume long);   Under above configuration, for each event, a file will be generated if there's no such a file,and then data will be written to that file as json messagesoutput will looks like below. { \u00a0\u00a0\u00a0\u00a0\"event\":{ \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"symbol\":\"WSO2\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"price\":55.6, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"volume\":100 \u00a0\u00a0\u00a0\u00a0} }",
            "title": "file (Sink)"
        },
        {
            "location": "/api/1.0.0/#source",
            "text": "",
            "title": "Source"
        },
        {
            "location": "/api/1.0.0/#file-source",
            "text": "File Source provides the functionality for user to feed data to siddhi from files. Both text and binary files are supported by file source.  Syntax  @source(type=\"file\", dir.uri=\"<STRING>\", file.uri=\"<STRING>\", mode=\"<STRING>\", tailing=\"<BOOL>\", action.after.process=\"<STRING>\", action.after.failure=\"<STRING>\", move.after.process=\"<STRING>\", move.after.failure=\"<STRING>\", begin.regex=\"<STRING>\", end.regex=\"<STRING>\", file.polling.interval=\"<STRING>\", dir.polling.interval=\"<STRING>\", @map(...)))  QUERY PARAMETERS  \n     \n         Name \n         Description \n         Default Value \n         Possible Data Types \n         Optional \n         Dynamic \n     \n     \n         dir.uri \n         Used to specify a directory to be processed.  All the files inside this directory will be processed.  Only one of 'dir.uri' and 'file.uri' should be provided. \n         \n         STRING \n         No \n         No \n     \n     \n         file.uri \n         Used to specify a file to be processed.  \u00a0Only one of 'dir.uri' and 'file.uri' should be provided. \n         \n         STRING \n         No \n         No \n     \n     \n         mode \n         This parameter is used to specify how files in given directory should.Possible values for this parameter are, 1. TEXT.FULL : to read a text file completely at once. 2. BINARY.FULL : to read a binary file completely at once. 3. LINE : to read a text file line by line. 4. REGEX : to read a text file and extract data using a regex. \n         line \n         STRING \n         Yes \n         No \n     \n     \n         tailing \n         This can either have value true or false. By default it will be true.  This attribute allows user to specify whether the file should be tailed or not.  If tailing is enabled, the first file of the directory will be tailed. Also tailing should not be enabled in 'binary.full' or 'text.full' modes. \n         true \n         BOOL \n         Yes \n         No \n     \n     \n         action.after.process \n         This parameter is used to specify the action which should be carried out  after processing a file in the given directory.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. \n         delete \n         STRING \n         Yes \n         No \n     \n     \n         action.after.failure \n         This parameter is used to specify the action which should be carried out if a failure occurred during the process.  It can be either DELETE or MOVE and default value will be 'DELETE'. If the action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.process \n         If action.after.process is MOVE, user must specify the location to move consumed files using 'move.after.process' parameter. This should be the absolute path of the file that going to be created after moving is done. \n         \n         STRING \n         No \n         No \n     \n     \n         move.after.failure \n         If action.after.failure is MOVE, user must specify the location to move consumed files using 'move.after.failure' parameter. This should be the absolute path of the file that going to be created after moving is done. \n         \n         STRING \n         No \n         No \n     \n     \n         begin.regex \n         This will define the regex to be matched at the beginning of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         end.regex \n         This will define the regex to be matched at the end of the retrieved content. \n         None \n         STRING \n         Yes \n         No \n     \n     \n         file.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a file. \n         1000 \n         STRING \n         Yes \n         No \n     \n     \n         dir.polling.interval \n         This parameter is used to specify the time period (in milliseconds) of a polling cycle for a directory. \n         1000 \n         STRING \n         Yes \n         No \n       Examples  EXAMPLE 1  @source(type='file',\nmode='text.full',\ntailing='false'\n dir.uri='/abc/xyz',\naction.after.process='delete',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);   Under above configuration, all the files in directory will be picked and read one by one. In this case, it's assumed that all the files contains json valid json strings with keys 'symbol','price' and 'volume'. Once a file is read, its content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Finally, after reading is finished, the file will be deleted.  EXAMPLE 2  @source(type='file',\nmode='files.repo.line',\ntailing='true',\ndir.uri='/abc/xyz',\n@map(type='json')) \ndefine stream FooStream (symbol string, price float, volume long);  Under above configuration, the first file in directory '/abc/xyz'  will be picked and read line by line. In this case, it is assumed that the file contains lines json strings. For each line, line content will be converted to an event using siddhi-map-json extension and then, that event will be received to the FooStream. Once file content is completely read, it will keep checking whether a new entry is added to the file or not. If such entry is added, it will be immediately picked up and processed.",
            "title": "file (Source)"
        }
    ]
}